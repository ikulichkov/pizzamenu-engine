{
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\bd.js": "// db.js ‚Äî –∞–¥—Ä–µ—Å–∞/—Ç–µ–ª–µ—Ñ–æ–Ω—ã/–∫–æ—Ä–∑–∏–Ω–∞ + –ø–æ—Ä—è–¥–æ–∫ –º–µ–Ω—é (MenuOrder)\r\n\r\nimport mongoose from 'mongoose';\r\nimport crypto from 'crypto';\r\n\r\nconst MONGO_URL = 'mongodb://127.0.0.1:27017/pizza25';\r\nconst DB = { ready: false, Address: null, Phone: null, Cart: null, MenuOrder: null };\r\n\r\nexport async function dbInit() {\r\n    if (DB.ready) return true;\r\n    try {\r\n        await mongoose.connect(MONGO_URL, { dbName: 'pizza25', serverSelectionTimeoutMS: 1500 });\r\n\r\n        const AddressSchema = new mongoose.Schema({\r\n            userId:      { type: Number, index: true, required: true },\r\n            addressFull: { type: String, required: true },\r\n            addressJSON: { type: mongoose.Schema.Types.Mixed, required: true },\r\n            createdAt:   { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        AddressSchema.index({ userId: 1, addressFull: 1 }, { unique: true });\r\n\r\n        const PhoneSchema = new mongoose.Schema({\r\n            userId:    { type: Number, index: true, required: true },\r\n            phone:     { type: String, required: true },\r\n            isPrimary: { type: Boolean, default: false },\r\n            createdAt: { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        PhoneSchema.index({ userId: 1, phone: 1 }, { unique: true });\r\n\r\n        // –ö–æ—Ä–∑–∏–Ω–∞: –æ–¥–∏–Ω –¥–æ–∫—É–º–µ–Ω—Ç –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\r\n        const CartSchema = new mongoose.Schema({\r\n            userId:   { type: Number, index: true, required: true },\r\n            items:    [{\r\n                id:    { type: String, required: true },\r\n                name:  { type: String, required: true },\r\n                cost:  { type: Number, required: true },\r\n                count: { type: Number, required: true }\r\n            }],\r\n            updatedAt: { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        CartSchema.index({ userId: 1 }, { unique: true });\r\n\r\n        // –ü–æ—Ä—è–¥–æ–∫ –∏ —Å–∫—Ä—ã—Ç–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –º–µ–Ω—é (–≥–ª–æ–±–∞–ª—å–Ω–æ –¥–ª—è –≤—Å–µ—Ö)\r\n        const MenuOrderSchema = new mongoose.Schema({\r\n            parentId:   { type: String, index: true, default: null }, // null == –∫–æ—Ä–µ–Ω—å\r\n            orderedIds: { type: [String], default: [] },\r\n            hiddenIds:  { type: [String], default: [] },\r\n            updatedAt:  { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        MenuOrderSchema.index({ parentId: 1 }, { unique: true });\r\n\r\n        DB.Address   = mongoose.model('TelegramAddress', AddressSchema);\r\n        DB.Phone     = mongoose.model('TelegramPhone',   PhoneSchema);\r\n        DB.Cart      = mongoose.model('TelegramCart',    CartSchema);\r\n        DB.MenuOrder = mongoose.model('MenuOrder',       MenuOrderSchema);\r\n\r\n        DB.ready = true;\r\n        return true;\r\n    } catch (e) {\r\n        console.error('[DB] –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞:', e?.message || e);\r\n        DB.ready = false;\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function dbGetAddresses(userId, limit = 6) {\r\n    if (!await dbInit()) return [];\r\n    return DB.Address.find({ userId }).sort({ createdAt: -1 }).limit(limit).lean().exec();\r\n}\r\n\r\nexport async function dbSaveAddress(userId, addressFull, addressJSON) {\r\n    if (!await dbInit()) return;\r\n    try {\r\n        await DB.Address.updateOne(\r\n            { userId, addressFull },\r\n            { $setOnInsert: { addressJSON, createdAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch {}\r\n}\r\n\r\nexport async function dbSavePhone(userId, phone, isPrimary = false) {\r\n    if (!await dbInit()) return;\r\n    try {\r\n        await DB.Phone.updateOne(\r\n            { userId, phone },\r\n            { $setOnInsert: { isPrimary, createdAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n        if (isPrimary) {\r\n            await DB.Phone.updateMany(\r\n                { userId, phone: { $ne: phone } },\r\n                { $set: { isPrimary: false } }\r\n            ).exec();\r\n        }\r\n    } catch {}\r\n}\r\n\r\n// ====== –∫–æ—Ä–∑–∏–Ω–∞ ======\r\nexport async function dbLoadCart(userId) {\r\n    if (!await dbInit()) return [];\r\n    const doc = await DB.Cart.findOne({ userId }).lean().exec();\r\n    return Array.isArray(doc?.items) ? doc.items : [];\r\n}\r\nexport async function dbSaveCart(userId, items) {\r\n    if (!await dbInit()) return;\r\n    try {\r\n        await DB.Cart.updateOne(\r\n            { userId },\r\n            { $set: { items: Array.isArray(items) ? items : [], updatedAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch {}\r\n}\r\n\r\n// ====== –ø–æ—Ä—è–¥–æ–∫ –º–µ–Ω—é (–≥–ª–æ–±–∞–ª—å–Ω–æ) ======\r\nexport async function dbLoadAllMenuOrders() {\r\n    if (!await dbInit()) return [];\r\n    return DB.MenuOrder.find({}).lean().exec();\r\n}\r\n\r\n/**\r\n * –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –∏ —Å–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è —Ä–æ–¥–∏—Ç–µ–ª—è\r\n * @param {string|null} parentId\r\n * @param {string[]} orderedIds\r\n * @param {string[]} hiddenIds\r\n */\r\nexport async function dbSaveMenuOrder(parentId, orderedIds = [], hiddenIds = []) {\r\n    if (!await dbInit()) return;\r\n    try {\r\n        await DB.MenuOrder.updateOne(\r\n            { parentId: parentId == null ? null : String(parentId) },\r\n            {\r\n                $set: {\r\n                    orderedIds: orderedIds.map(String),\r\n                    hiddenIds:  hiddenIds.map(String),\r\n                    updatedAt:  new Date()\r\n                }\r\n            },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch (e) {\r\n        console.error('[DB] menuOrder save error:', e?.message || e);\r\n    }\r\n}\r\n\r\n// ====== UUID v5 (–∫–∞–∫ –±—ã–ª–æ) ======\r\nexport function generateStableUuid(name, namespace = '1b671a64-40d5-491e-99b0-da01ff1f3341') {\r\n    const ns = namespace.replace(/-/g, '');\r\n    const nsBytes = Buffer.from(ns, 'hex');\r\n    const nameBytes = Buffer.from(String(name), 'utf8');\r\n    const hash = crypto.createHash('sha1').update(nsBytes).update(nameBytes).digest();\r\n    hash[6] = (hash[6] & 0x0f) | 0x50;\r\n    hash[8] = (hash[8] & 0x3f) | 0x80;\r\n    const b = hash.subarray(0, 16);\r\n    const hex = b.toString('hex');\r\n    return [hex.slice(0,8),hex.slice(8,12),hex.slice(12,16),hex.slice(16,20),hex.slice(20)].join('-');\r\n}\r\n\r\n// ====== –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è Presto ======\r\nexport function normalizeCalendarIntervals(raw) {\r\n    const out = new Set();\r\n\r\n    const addIndex = (i) => {\r\n        const n = Number(i);\r\n        if (Number.isInteger(n) && n >= 0 && n <= 47) out.add(n);\r\n    };\r\n\r\n    const addRange = (a, b) => {\r\n        let x = Number(a), y = Number(b);\r\n        if (!Number.isFinite(x) || !Number.isFinite(y)) return;\r\n        const start = Math.max(0, Math.min(x, y));\r\n        const end   = Math.min(47, Math.max(x, y));\r\n        for (let i = start; i <= end; i++) addIndex(i);\r\n    };\r\n\r\n    const walk = (val) => {\r\n        if (val == null) return;\r\n\r\n        if (typeof val === 'number') { addIndex(val); return; }\r\n\r\n        if (typeof val === 'string') {\r\n            const s = val.trim();\r\n            if (s.toLowerCase() === 'all') { addRange(0, 47); return; }\r\n            const m = s.match(/^(\\d{1,2})\\s*-\\s*(\\d{1,2})$/);\r\n            if (m) { addRange(m[1], m[2]); return; }\r\n            addIndex(s);\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(val)) {\r\n            if (val.length === 2 && val.every(x => Number.isFinite(Number(x)))) {\r\n                addRange(val[0], val[1]);\r\n            } else {\r\n                for (const v of val) walk(v);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (typeof val === 'object') {\r\n            for (const k of Object.keys(val)) walk(val[k]);\r\n        }\r\n    };\r\n\r\n    walk(raw);\r\n    return [...out].sort((a, b) => a - b);\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\index.js": "console.log('Happy developing ‚ú®')\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\engine.js": "// –Ø–¥—Ä–æ –¥–≤–∏–∂–∫–∞. –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ callback-–¥–∞–Ω–Ω—ã—Ö: —Ç–æ–ª—å–∫–æ \"m:*\", –∫–∞–∫ –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ 1. (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)\r\n// –ö–æ–º–∞–Ω–¥—ã: –∏–∑ 4 (+ /sort –¥–ª—è –∞–¥–º–∏–Ω–∞, –ø–∞—Ä–∏—Ç–µ—Ç —Å A –∏–∑ 2). /start —Å–æ—Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å —á—É–∂–∏–º, —Å–º. ctx.state.handled.\r\n// TZ: Intl.* –±–µ–∑ luxon.\r\n\r\nimport { createSabyClient } from './saby.js';\r\nimport { nowTZMinutesSinceMidnight, slotLabel, toLocalPrestoDate, humanDateShort, isTodayInTZ } from './util-date.js';\r\nimport { priceLabel, encId, decId, normalizePhone } from './shared.js';\r\n\r\nconst MENU_PREFIX = 'm:'; // –≤—Å—ë, —á—Ç–æ –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å m:, ‚Äî –Ω–µ –Ω–∞—à–µ –∏ –∏–≥–Ω–æ—Ä–∏–º. (–≤–∞—Ä–∏–∞–Ω—Ç 1)\r\n\r\nconst DEFAULTS = {\r\n    business: { timeZone: 'Asia/Vladivostok', slotOpenIdx: 20, slotCloseIdx: 42, adminId: 0 },\r\n    saby: { fixedPriceListId: 64, fixedPriceListName: '–ë–∞—Ä –æ—Å–Ω–æ–≤–Ω–æ–π' },\r\n    shop: { shopURL: 'https://pizza25.ru', successURL: 'https://pizza25.ru/pay/success', errorURL: 'https://pizza25.ru/pay/error' },\r\n    ui: { pageSize: 12 }\r\n};\r\n\r\n/** @typedef {{ready:()=>Promise<boolean>, getAddresses:(userId:number,limit?:number)=>Promise<any[]>, saveAddress:(userId:number,full:string,json:any)=>Promise<void>, savePhone:(userId:number,phone:string,isPrimary?:boolean)=>Promise<void>, loadCart:(userId:number)=>Promise<any[]>, saveCart:(userId:number,items:any[])=>Promise<void>, loadAllMenuOrders:()=>Promise<Array<{parentId:string|null, orderedIds:string[], hiddenIds:string[]}>>, saveMenuOrder:(parentId:string|null, orderedIds:string[], hiddenIds:string[])=>Promise<void>}} Storage */\r\n\r\nexport async function createEngine({ saby, business, shop, storage, debug = 1 }) {\r\n    const cfg = {\r\n        business: { ...DEFAULTS.business, ...business },\r\n        saby: { ...DEFAULTS.saby, ...saby },\r\n        shop: { ...DEFAULTS.shop, ...shop },\r\n        ui: DEFAULTS.ui\r\n    };\r\n\r\n    // Saby –∫–ª–∏–µ–Ω—Ç\r\n    const SABY = createSabyClient({\r\n        clientId: saby.clientId, secretKey: saby.secretKey, serviceKey: saby.serviceKey,\r\n        authUrl: saby.authUrl, apiBase: saby.apiBase\r\n    });\r\n\r\n    // Runtime –∫—ç—à –∫–∞—Ç–∞–ª–æ–≥–∞/–ø—Ä–∞–π—Å–∞/–ø–æ—Ä—è–¥–∫–∞\r\n    let POINT_ID = null;\r\n    let CATALOG = { byId: new Map(), parentById: new Map(), foldersByParent: new Map(), itemsByParent: new Map(), ROOT: '__root__' };\r\n    const CATEGORY_ORDER = new Map(); // parentId -> { order:string[], hidden:Set<string> }\r\n    const STATE = new Map(); // chatId -> { cart, cartLoaded, sortMode?:boolean, currentPriceListId, currentPriceListName, catId?:string|null }\r\n\r\n    const commands = [\r\n        { command: 'menu', description: '–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é' },\r\n        { command: 'cart', description: '–ö–æ—Ä–∑–∏–Ω–∞' },\r\n        { command: 'delivery', description: '–û—Ñ–æ—Ä–º–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É' }\r\n    ];\r\n    if (cfg.business.adminId) commands.push({ command: 'sort', description: '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –º–µ–Ω—é (admin)' });\r\n\r\n    // ========= helpers =========\r\n    const log = (...a) => { if (debug) console.log('[menu6]', ...a); };\r\n\r\n    function getState(chatId) {\r\n        if (!STATE.has(chatId)) STATE.set(chatId, {});\r\n        const st = STATE.get(chatId);\r\n        if (!Array.isArray(st.cart)) st.cart = [];\r\n        if (!st.cartLoaded) st.cartLoaded = false;\r\n        if (!st.currentPriceListId) st.currentPriceListId = cfg.saby.fixedPriceListId;\r\n        if (!st.currentPriceListName) st.currentPriceListName = cfg.saby.fixedPriceListName;\r\n        return st;\r\n    }\r\n\r\n    async function ensureCartLoaded(chatId) {\r\n        const st = getState(chatId);\r\n        if (st.cartLoaded) return st;\r\n        try { st.cart = await storage.loadCart(chatId) || []; } catch {}\r\n        st.cartLoaded = true; return st;\r\n    }\r\n\r\n    function applyOrderFor(parentId, ids) {\r\n        const rec = CATEGORY_ORDER.get(parentId == null ? null : String(parentId));\r\n        if (!rec) return ids.slice();\r\n        const hidden = new Set(rec.hiddenIds || rec.hidden || []);\r\n        const order = Array.isArray(rec.orderedIds) ? rec.orderedIds.map(String) : [];\r\n        const visible = ids.filter(x => !hidden.has(String(x)));\r\n        // –°–Ω–∞—á–∞–ª–∞ —Ç–æ, —á—Ç–æ –≤ order, –∑–∞—Ç–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ –∏—Å—Ö–æ–¥–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É\r\n        const inOrder = order.filter(x => visible.includes(x));\r\n        const rest = visible.filter(x => !inOrder.includes(x));\r\n        return [...inOrder, ...rest];\r\n    }\r\n\r\n    // ========= –∫–∞—Ç–∞–ª–æ–≥/–ø—Ä–∞–π—Å =========\r\n    async function refreshCatalog() {\r\n        if (!POINT_ID) {\r\n            const pts = await SABY.getPoints();\r\n            POINT_ID = SABY.pickPointId(pts) || null;\r\n            if (!POINT_ID) throw new Error('No Saby pointId');\r\n        }\r\n        const pl = await SABY.getPriceLists(POINT_ID);\r\n        // –≤—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π –ø—Ä–∞–π—Å\r\n        const picked = Array.isArray(pl?.records) ? pl.records.find(r => Number(r.id) === Number(cfg.saby.fixedPriceListId)) : null;\r\n        const pid = picked?.id ?? cfg.saby.fixedPriceListId;\r\n\r\n        // —Ç—è–Ω–µ–º –Ω–æ–º–µ–Ω–∫–ª–∞—Ç—É—Ä—É\r\n        const all = await SABY.getNomenclature(POINT_ID, pid, 0, 1000);\r\n\r\n        // –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è: –¥–µ—Ä–µ–≤–æ\r\n        const byId = new Map(); const parentById = new Map();\r\n        const foldersByParent = new Map(); const itemsByParent = new Map();\r\n        const ROOT = '__root__';\r\n\r\n        const raw = Array.isArray(all?.items) ? all.items\r\n            : Array.isArray(all?.records) ? all.records\r\n                : [];\r\n\r\n        // 1) –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ —Ç–æ–ª—å–∫–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã—Ö\r\n        //    isPublished === false -> —Å–∫—Ä—ã–≤–∞–µ–º (–∏ –ø–∞–ø–∫–∏, –∏ —Ç–æ–≤–∞—Ä—ã)\r\n        const rows = raw.filter(row => row?.isPublished !== false);\r\n\r\n        // 2) –ü—Ä–æ—Ö–æ–¥: –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è\r\n        for (const row of rows) {\r\n            const id = String(row.id);\r\n            const parentId = row.parentId == null ? ROOT : String(row.parentId);\r\n            const folder = !!row.group || !!row.folder;\r\n            const cost = Number(row.price || row.cost || 0);\r\n\r\n            // —É–∑–µ–ª\r\n            byId.set(id, {\r\n                id,\r\n                name: String(row.name || row.title || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),\r\n                folder,\r\n                cost\r\n            });\r\n            parentById.set(id, parentId);\r\n\r\n            // —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∫–æ—Ä–∑–∏–Ω–∞–º\r\n            const map = folder ? foldersByParent : itemsByParent;\r\n            if (!map.has(parentId)) map.set(parentId, []);\r\n            map.get(parentId).push(id);\r\n        }\r\n\r\n        CATALOG = { byId, parentById, foldersByParent, itemsByParent, ROOT };\r\n\r\n        // –ø–æ—Ä—è–¥–æ–∫/—Å–∫—Ä—ã—Ç–∏–µ –∏–∑ –ë–î\r\n        const rowsOrder = await storage.loadAllMenuOrders().catch(() => []);\r\n        CATEGORY_ORDER.clear();\r\n        for (const rec of rowsOrder) {\r\n            CATEGORY_ORDER.set(rec.parentId == null ? null : String(rec.parentId), {\r\n                orderedIds: (rec.orderedIds || []).map(String),\r\n                hidden: new Set((rec.hiddenIds || []).map(String)),\r\n                hiddenIds: (rec.hiddenIds || []).map(String)\r\n            });\r\n        }\r\n        log('catalog refreshed, items:', byId.size);\r\n    }\r\n\r\n    // ========= —Ä–µ–Ω–¥–µ—Ä—ã UI =========\r\n    function mainCategories() {\r\n        const base = (CATALOG.foldersByParent.get(CATALOG.ROOT) || []).slice();\r\n        const ids = applyOrderFor(null, base);\r\n        return ids.map(id => ({ id, name: CATALOG.byId.get(id)?.name || '–ö–∞—Ç–∞–ª–æ–≥' }));\r\n    }\r\n\r\n    function replyKb(categories) {\r\n        const rows = [];\r\n        let row = [];\r\n        for (const c of categories) {\r\n            row.push({ text: c.name });\r\n            if (row.length === 3) { rows.push(row); row = []; }\r\n        }\r\n        if (row.length) rows.push(row);\r\n        rows.push([{ text: 'üìã –ú–µ–Ω—é' }, { text: 'üß∫ –ö–æ—Ä–∑–∏–Ω–∞' }, { text: 'üöö –î–æ—Å—Ç–∞–≤–∫–∞' }]);\r\n        return { reply_markup: { keyboard: rows, resize_keyboard: true, one_time_keyboard: false } };\r\n    }\r\n\r\n    async function __getStartPayload(chatIdOrCtx) {\r\n        const chatId = typeof chatIdOrCtx === 'number' ? chatIdOrCtx : chatIdOrCtx?.chat?.id;\r\n        const st = getState(chatId || 0);\r\n        const cats = mainCategories();\r\n        const text = `–ú–µ–Ω—é: ${st.currentPriceListName}`;\r\n        const extra = replyKb(cats);\r\n        return { text, extra };\r\n    }\r\n\r\n    async function sendStartUi(ctx) {\r\n        const { text, extra } = await __getStartPayload(ctx);\r\n        console.log(`text, extra`, text, extra)\r\n        await ctx.reply(text, extra);\r\n    }\r\n\r\n    async function sendCategory(ctx, catId = null, page = 0) {\r\n        const st = getState(ctx.chat.id);\r\n        st.catId = catId;\r\n\r\n        const parentKey = catId ?? CATALOG.ROOT;\r\n        const folders = applyOrderFor(catId, CATALOG.foldersByParent.get(parentKey) || []);\r\n        const itemsAll = CATALOG.itemsByParent.get(parentKey) || [];\r\n\r\n        // –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ, –µ—Å–ª–∏ –≤ –ø–∞–ø–∫–µ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤\r\n        if (!itemsAll.length && folders.length) {\r\n            return sendCategory(ctx, folders[0], 0);\r\n        }\r\n\r\n        const pageSize =  cfg.ui.pageSize;\r\n        const start     =  page * pageSize;\r\n        const itemsPage = itemsAll.slice(start, start + pageSize);\r\n\r\n        const rows = [];\r\n\r\n        // –ø–æ–¥–ø–∞–ø–∫–∏\r\n        if (folders.length && itemsAll.length) {\r\n            for (const fid of folders) {\r\n                rows.push([{ text: `üìÇ ${CATALOG.byId.get(fid)?.name || '–ö–∞—Ç–∞–ª–æ–≥'}`, callback_data: `${MENU_PREFIX}cat:${encId(fid)}:0` }]);\r\n            }\r\n        }\r\n\r\n        // —Ç–æ–≤–∞—Ä—ã\r\n        for (const iid of itemsPage) {\r\n            const it = CATALOG.byId.get(iid);\r\n            rows.push([{ text: `${it.name} ‚Ä¢ ${priceLabel(it.cost)}`, callback_data: `${MENU_PREFIX}add:${it.id}` }]);\r\n        }\r\n\r\n        // –ø–∞–≥–∏–Ω–∞—Ü–∏—è\r\n        const totalPages = Math.ceil(itemsAll.length / pageSize);\r\n        if (totalPages > 1) {\r\n            const nav = [];\r\n            for (let p = Math.max(0, page - 2); p <= Math.min(totalPages - 1, page + 2); p++) {\r\n                nav.push({ text: p === page ? `üëÅ ${p + 1}` : `${p + 1}`, callback_data: `${MENU_PREFIX}ipage:${encId(catId ?? 'root')}:${p}` });\r\n            }\r\n            rows.push(nav);\r\n        }\r\n\r\n        // –∫–æ—Ä–∑–∏–Ω–∞\r\n        const stCart = await ensureCartLoaded(ctx.chat.id);\r\n        const total = stCart.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n        const count = stCart.cart.reduce((s, r) => s + r.count, 0);\r\n\r\n        rows.push([\r\n            { text: `üß∫ –ö–æ—Ä–∑–∏–Ω–∞ (${count} | ${priceLabel(total)})`, callback_data: `${MENU_PREFIX}cart:show` },\r\n            { text: 'üöö –û—Ñ–æ—Ä–º–∏—Ç—å', callback_data: `${MENU_PREFIX}order:start` }\r\n        ]);\r\n\r\n        const title = catId ? `–ú–µ–Ω—é: ${st.currentPriceListName} / ${CATALOG.byId.get(catId)?.name || ''}` : `–ú–µ–Ω—é: ${st.currentPriceListName}`;\r\n        await ctx.reply(title, { reply_markup: { inline_keyboard: rows } });\r\n    }\r\n\r\n    async function showCart(ctx) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        if (!st.cart.length) return ctx.reply('–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞.');\r\n        const total = st.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n        const rows = st.cart.map(r => ([\r\n            { text: '‚àí', callback_data: `${MENU_PREFIX}cart:dec:${r.id}` },\r\n            { text: `${r.name} √ó${r.count}`, callback_data: `${MENU_PREFIX}noop` },\r\n            { text: '+', callback_data: `${MENU_PREFIX}cart:inc:${r.id}` },\r\n            { text: '‚úñ', callback_data: `${MENU_PREFIX}cart:del:${r.id}` }\r\n        ]));\r\n        rows.push([{ text: '–û—á–∏—Å—Ç–∏—Ç—å', callback_data: `${MENU_PREFIX}cart:clear` }, { text: 'üöö –û—Ñ–æ—Ä–º–∏—Ç—å', callback_data: `${MENU_PREFIX}order:start` }]);\r\n        await ctx.reply(\r\n            `üß∫ –ö–æ—Ä–∑–∏–Ω–∞:\\n${st.cart.map(r => `‚Ä¢ ${r.name} √ó ${r.count} = ${priceLabel(r.cost * r.count)}`).join('\\n')}\\n\\n–ò—Ç–æ–≥–æ: ${priceLabel(total)}`,\r\n            { reply_markup: { inline_keyboard: rows } }\r\n        );\r\n    }\r\n\r\n    // ========= –¥–µ–π—Å—Ç–≤–∏—è —Å –∫–æ—Ä–∑–∏–Ω–æ–π =========\r\n    async function addToCart(ctx, itemId) {\r\n        const id = String(itemId);\r\n        const node = CATALOG.byId.get(id);\r\n        if (!node || node.folder) return;\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const row = st.cart.find(r => r.id === id);\r\n        if (row) row.count += 1;\r\n        else st.cart.push({ id, name: node.name, cost: node.cost, count: 1 });\r\n        await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n        await ctx.answerCbQuery(`${node.name} –¥–æ–±–∞–≤–ª–µ–Ω`);\r\n    }\r\n    async function changeQty(ctx, id, delta) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const i = st.cart.findIndex(r => r.id === id);\r\n        if (i < 0) return;\r\n        st.cart[i].count = Math.max(1, (st.cart[i].count || 1) + delta);\r\n        await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n    }\r\n    async function delItem(ctx, id) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const before = st.cart.length;\r\n        st.cart = st.cart.filter(r => r.id !== id);\r\n        if (st.cart.length !== before) await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n    }\r\n\r\n    // ========= —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∞ =========\r\n    function isAdmin(ctx) { return cfg.business.adminId && Number(ctx.from?.id) === Number(cfg.business.adminId); }\r\n\r\n    async function toggleSortMode(ctx) {\r\n        if (!isAdmin(ctx)) return ctx.reply('–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É.');\r\n        const st = getState(ctx.chat.id);\r\n        st.sortMode = !st.sortMode;\r\n        await ctx.reply(st.sortMode ? '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –í–ö–õ' : '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –í–´–ö–õ');\r\n    }\r\n\r\n    // ========= delivery flow (–º–∏–Ω–∏–º–∞–ª—å–Ω–æ, –±–µ–∑ —ç–∫—Å—Ç—Ä–∏–º–∞) =========\r\n    async function startDelivery(ctx) {\r\n        await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π (—É–ª–∏—Ü–∞ –¥–æ–º, –∫–≤–∞—Ä—Ç–∏—Ä–∞):');\r\n        const st = getState(ctx.chat.id);\r\n        st.flow = 'address';\r\n    }\r\n\r\n    async function onText(ctx) {\r\n        const text = (ctx.message?.text || '').trim();\r\n\r\n        // –≥–ª–∞–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏\r\n        if (text === 'üìã –ú–µ–Ω—é') return sendCategory(ctx, null, 0);\r\n        if (text === 'üß∫ –ö–æ—Ä–∑–∏–Ω–∞') return showCart(ctx);\r\n        if (text === 'üöö –î–æ—Å—Ç–∞–≤–∫–∞') return startDelivery(ctx);\r\n\r\n        // –∫–ª–∏–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏\r\n        const cat = mainCategories().find(c => c.name === text);\r\n        if (cat) return sendCategory(ctx, cat.id, 0);\r\n\r\n        // –ø—Ä–æ—Å—Ç–µ–π—à–∏–π —à–∞–≥ –∞–¥—Ä–µ—Å–∞\r\n        const st = getState(ctx.chat.id);\r\n        if (st.flow === 'address') {\r\n            const sugg = await SABY.suggestedAddress(text).catch(()=>null);\r\n            const best = Array.isArray(sugg?.records) ? sugg.records[0] : null;\r\n            if (!best) return ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∞–¥—Ä–µ—Å, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–Ω–∞—á–µ.');\r\n            await storage.saveAddress(ctx.from.id, best.fullAddress || text, best);\r\n            st.flow = 'slot';\r\n            await ctx.reply('–ê–¥—Ä–µ—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏:');\r\n            // –∫–∞–ª–µ–Ω–¥–∞—Ä—å: —Ç—É—Ç –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–ª–∏–∂–∞–π—à–∏–µ 6 —Å–ª–æ—Ç–æ–≤ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏—Ö\r\n            const minutes = nowTZMinutesSinceMidnight(cfg.business.timeZone);\r\n            const startIdx = Math.max(cfg.business.slotOpenIdx, Math.floor((minutes - 30) / 30));\r\n            const endIdx = cfg.business.slotCloseIdx;\r\n            const row = [];\r\n            for (let idx = startIdx; idx <= Math.min(endIdx, startIdx + 5); idx++) {\r\n                row.push({ text: slotLabel(idx), callback_data: `${MENU_PREFIX}slot:${idx}` });\r\n            }\r\n            return ctx.reply('–î–æ—Å—Ç—É–ø–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞:', { reply_markup: { inline_keyboard: [row] } });\r\n        }\r\n    }\r\n\r\n    async function onAction(ctx) {\r\n        const data = String(ctx.update?.callback_query?.data || '');\r\n        if (!data.startsWith(MENU_PREFIX)) return; // —á—É–∂–∏–µ callback-–∏ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º (–≤–∞—Ä–∏–∞–Ω—Ç 1)\r\n        const cmd = data.slice(MENU_PREFIX.length);\r\n\r\n        // –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∏ –∫–æ—Ä–∑–∏–Ω–∞\r\n        if (cmd.startsWith('cat:')) {\r\n            const [, b64, pageStr] = cmd.split(':'); const id = decId(b64);\r\n            return sendCategory(ctx, id === 'root' ? null : id, Number(pageStr || 0) || 0);\r\n        }\r\n        if (cmd.startsWith('ipage:')) {\r\n            const [, b64, pageStr] = cmd.split(':'); const id = decId(b64);\r\n            return sendCategory(ctx, id === 'root' ? null : id, Number(pageStr || 0) || 0);\r\n        }\r\n        if (cmd.startsWith('add:')) {\r\n            const id = cmd.slice('add:'.length);\r\n            await addToCart(ctx, id);\r\n            return;\r\n        }\r\n        if (cmd === 'cart:show') return showCart(ctx);\r\n        if (cmd.startsWith('cart:dec:')) { await changeQty(ctx, cmd.split(':')[2], -1); return showCart(ctx); }\r\n        if (cmd.startsWith('cart:inc:')) { await changeQty(ctx, cmd.split(':')[2], +1); return showCart(ctx); }\r\n        if (cmd.startsWith('cart:del:')) { await delItem(ctx, cmd.split(':')[2]); return showCart(ctx); }\r\n        if (cmd === 'cart:clear') {\r\n            const st = await ensureCartLoaded(ctx.chat.id);\r\n            st.cart = []; await storage.saveCart(ctx.chat.id, []);\r\n            return showCart(ctx);\r\n        }\r\n\r\n        // —Å–ª–æ—Ç—ã\r\n        if (cmd.startsWith('slot:')) {\r\n            const slotIdx = Number(cmd.split(':')[1]);\r\n            await ctx.answerCbQuery(`–°–ª–æ—Ç ${slotLabel(slotIdx)} –≤—ã–±—Ä–∞–Ω. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –≤—ã–Ω–µ—Å–µ–Ω–æ –≤ TODO.`);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // ========= –ø—É–±–ª–∏—á–Ω—ã–π API =========\r\n    async function attach(bot) {\r\n        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ\r\n        await refreshCatalog().catch(e => log('catalog init failed', e?.message || e));\r\n\r\n        // –Ω–∞—à ¬´–≤—Ç–æ—Ä–æ–π /start¬ª ‚Äî –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —á—É–∂–æ–π, —Ç–æ–ª—å–∫–æ –¥–æ–ø–æ–ª–Ω—è–µ—Ç (–≤–∞—Ä–∏–∞–Ω—Ç 4 + —É–≤–∞–∂–µ–Ω–∏–µ –∫ ctx.state.handled)\r\n        bot.start(async (ctx, next) => {\r\n            try {\r\n                if (!ctx.state?.handled) await sendStartUi(ctx);\r\n            } catch {}\r\n            return next && next();\r\n        });\r\n\r\n        bot.command('menu', ctx => sendCategory(ctx, null, 0));\r\n        bot.command('cart', ctx => showCart(ctx));\r\n        bot.command('delivery', ctx => startDelivery(ctx));\r\n        if (cfg.business.adminId) bot.command('sort', ctx => toggleSortMode(ctx));\r\n\r\n        // —Ç–µ–∫—Å—Ç–æ–≤—ã–µ\r\n        bot.on('text', onText);\r\n\r\n        // —Ç–æ–ª—å–∫–æ –Ω–∞—à–∏ callback-–∏, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å m:\r\n        bot.action(/^m:/, onAction);\r\n    }\r\n\r\n    return {\r\n        attach,\r\n        sendStartUi,\r\n        commands,\r\n        __getStartPayload, // –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (getStartPayload)\r\n    };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\index.js": "// –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç: —Ñ–∞–±—Ä–∏–∫–∞ –¥–≤–∏–∂–∫–∞. –ë–∞–∑–∞ ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç 4, —Å –∞–ª–∏–∞—Å–∞–º–∏ –∏–∑ 2/3.\r\n// –ò—Å—Ç–æ—á–Ω–∏–∫ –∏–¥–µ–π API: 4.md (attach/sendStartUi/commands), —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: 2.md (register/startContent) –∏ 3.md (getStartPayload).\r\nimport { createEngine } from './engine.js';\r\n\r\n/**\r\n * @param {Object} config\r\n * @param {Object} config.saby {clientId, secretKey, serviceKey, authUrl?, apiBase?, fixedPriceListId?, fixedPriceListName?}\r\n * @param {Object} config.business { timeZone?, slotOpenIdx?, slotCloseIdx?, adminId? }\r\n * @param {Object} config.shop { shopURL?, successURL?, errorURL? }\r\n * @param {Object} [config.storage]  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∞–¥–∞–ø—Ç–µ—Ä —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (—Å–º. storage/types.js)\r\n * @param {Object} [config.mongo]    –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π mongoose-–∞–¥–∞–ø—Ç–µ—Ä: { url, dbName, connect?: boolean }\r\n * @param {number} [config.debug=1]\r\n * @returns {Promise<{\r\n *   attach: (bot: import('telegraf').Telegraf) => Promise<void>,\r\n *   register: (bot: import('telegraf').Telegraf) => Promise<void>,\r\n *   sendStartUi: (ctx: any) => Promise<void>,\r\n *   getStartPayload: (chatIdOrCtx: number|any) => Promise<{text:string, extra?:object}>,\r\n *   commands: Array<{command:string, description:string}>\r\n * }>}\r\n */\r\nexport default async function createMenuEngine(config = {}) {\r\n    const { saby, business = {}, shop = {}, storage, mongo, debug = 1 } = config;\r\n\r\n    let storageImpl = storage || null;\r\n\r\n    if (!storageImpl && mongo?.url) {\r\n        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–æ–¥–≥—Ä—É–∂–∞–µ–º mongoose-–∞–¥–∞–ø—Ç–µ—Ä (–≤–∞—Ä–∏–∞–Ω—Ç 4), –ù–û –∫–æ–Ω–Ω–µ–∫—Ç ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ connect === true\r\n        const { createMongooseAdapter } = await import('./storage/mongoose.js');\r\n        storageImpl = await createMongooseAdapter({\r\n            mongoUrl: mongo.url,\r\n            dbName: mongo.dbName || 'pizza25',\r\n            connect: Boolean(mongo.connect),\r\n            debug\r\n        });\r\n    }\r\n\r\n    if (!saby?.clientId || !saby?.secretKey || !saby?.serviceKey) {\r\n        throw new Error('[menu6] saby credentials are required (clientId, secretKey, serviceKey)');\r\n    }\r\n    if (!storageImpl) {\r\n        throw new Error('[menu6] storage adapter is required (custom storage or mongo.url with connect flag)');\r\n    }\r\n\r\n    const engine = await createEngine({ saby, business, shop, storage: storageImpl, debug });\r\n\r\n    // –°–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –∞–ª–∏–∞—Å—ã –ø–æ–¥ –≤–∞—Ä–∏–∞–Ω—Ç—ã 2/3:\r\n    engine.register = engine.attach;                   // 2.md register(bot)\r\n    engine.getStartPayload = engine.__getStartPayload; // 3.md getStartPayload(...)\r\n    return engine;\r\n}\r\n\r\nexport { default as createMenuEngine } from './index.js';\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\saby.js": "// –û–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ Saby API. –í–∑—è—Ç–æ –ø–æ —Ñ–æ—Ä–º–µ –∏–∑ 4 –∏ 3: auth, pickPointId, getPriceLists, getNomenclature, suggestedAddress, deliveryCost‚Ä¶\r\n// –ó–¥–µ—Å—å —Ä–æ–≤–Ω–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –¥–≤–∏–∂–∫—É. –ë–µ–∑ –ª–∏—à–Ω–µ–≥–æ.\r\n\r\nimport { /* short */ } from './shared.js';\r\n\r\nexport function createSabyClient({\r\n                                     clientId, secretKey, serviceKey,\r\n                                     authUrl = 'https://online.sbis.ru/oauth/service/',\r\n                                     apiBase = 'https://api.sbis.ru'\r\n                                 }) {\r\n    const RETAIL_BASE = `${apiBase}/retail`;\r\n    const SABY = { token: null, sid: null };\r\n\r\n    async function auth() {\r\n        const res = await fetch(authUrl, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type':'application/json; charset=utf-8', 'Accept':'application/json' },\r\n            body: JSON.stringify({ app_client_id: clientId, app_secret: secretKey, secret_key: serviceKey })\r\n        });\r\n        if (!res.ok) throw new Error(`Saby auth failed: ${res.status}`);\r\n        const data = await res.json();\r\n        SABY.token = data.token; SABY.sid = data.sid;\r\n    }\r\n    function headers() {\r\n        const h = { 'Accept':'application/json' };\r\n        if (SABY.token) h['X-SBISAccessToken'] = SABY.token;\r\n        if (SABY.sid)   h['Cookie'] = `sid=${SABY.sid}`;\r\n        return h;\r\n    }\r\n    async function call(url, opts = {}, retry = true) {\r\n        const res = await fetch(url, { method: opts.method || 'GET', headers: { ...headers(), ...(opts.headers || {}) }, body: opts.body });\r\n        const text = await res.text().catch(() => '');\r\n        if (res.status === 401 && retry) { await auth(); return call(url, opts, false); }\r\n        if (!res.ok) throw new Error(`${url} ‚Üí ${res.status} ${text}`);\r\n        try { return text ? JSON.parse(text) : {}; } catch { return { raw:text }; }\r\n    }\r\n\r\n    const getPoints = () => call(`${RETAIL_BASE}/point/list`);\r\n    function pickPointId(pointsResp) {\r\n        const list = Array.isArray(pointsResp?.salesPoints) ? pointsResp.salesPoints\r\n            : Array.isArray(pointsResp?.records) ? pointsResp.records\r\n                : Array.isArray(pointsResp) ? pointsResp : [];\r\n        return list[0]?.id ?? null;\r\n    }\r\n    const getPriceLists = (pointId, actualDate = new Date()) => {\r\n        const url = new URL(`${RETAIL_BASE}/nomenclature/price-list`);\r\n        url.searchParams.set('pointId', String(pointId));\r\n        url.searchParams.set('actualDate', `${actualDate.toLocaleDateString('ru-RU')} ${actualDate.toLocaleTimeString('ru-RU')}`);\r\n        url.searchParams.set('pageSize', '1000');\r\n        return call(url.toString());\r\n    };\r\n    const getNomenclature = (pointId, priceListId, page = 0, pageSize = 1000) => {\r\n        const url = new URL(`${RETAIL_BASE}/nomenclature/list`);\r\n        url.searchParams.set('pointId', String(pointId));\r\n        url.searchParams.set('priceListId', String(priceListId));\r\n        url.searchParams.set('page', String(page));\r\n        url.searchParams.set('pageSize', String(pageSize));\r\n        return call(url.toString());\r\n    };\r\n\r\n    const suggestedAddress = (addressLine) => {\r\n        const url = new URL(`${RETAIL_BASE}/delivery/suggested-address`);\r\n        url.searchParams.set('address', addressLine);\r\n        return call(url.toString());\r\n    };\r\n\r\n    // –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–∑–æ–≤—ã (deliveryCost, deliveryCalendar, createOrder, paymentLink –∏ —Ç.–¥.) –¥–æ–±–∞–≤–∏–º –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –æ–Ω–ª–∞–π–Ω-–æ–ø–ª–∞—Ç—ã.\r\n    return { getPoints, pickPointId, getPriceLists, getNomenclature, suggestedAddress };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\shared.js": "// –û–±—â–∏–µ —É—Ç–∏–ª–∏—Ç—ã: stable UUID, –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è, —Ü–µ–Ω–∞, b64id, —Ç–µ–ª–µ—Ñ–æ–Ω.\r\nimport crypto from 'crypto';\r\n\r\nexport const priceLabel = v => `${(Number(v) || 0).toFixed(0)} ‚ÇΩ`;\r\nexport const encId = id => Buffer.from(String(id), 'utf8').toString('base64url');\r\nexport const decId = s  => { try { return Buffer.from(String(s), 'base64url').toString('utf8'); } catch { return String(s); } };\r\n\r\nexport function normalizePhone(s) {\r\n    if (!s) return null;\r\n    let p = String(s).replace(/[^\\d+]/g, '');\r\n    if (/^8\\d{10}$/.test(p)) return `+7${p.slice(1)}`;\r\n    if (/^\\+7\\d{10}$/.test(p)) return p;\r\n    if (/^7\\d{10}$/.test(p)) return `+${p}`;\r\n    return null;\r\n}\r\n\r\nexport function generateStableUuid(name, namespace='1b671a64-40d5-491e-99b0-da01ff1f3341') {\r\n    const ns = namespace.replace(/-/g,''); const nsBytes = Buffer.from(ns,'hex');\r\n    const nameBytes = Buffer.from(String(name),'utf8');\r\n    const hash = crypto.createHash('sha1').update(nsBytes).update(nameBytes).digest();\r\n    hash[6] = (hash[6] & 0x0f) | 0x50; hash[8] = (hash[8] & 0x3f) | 0x80;\r\n    const b = hash.subarray(0,16); const hex = b.toString('hex');\r\n    return [hex.slice(0,8),hex.slice(8,12),hex.slice(12,16),hex.slice(16,20),hex.slice(20)].join('-');\r\n}\r\n\r\n// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è Presto (0..47)\r\nexport function normalizeCalendarIntervals(raw) {\r\n    const out = new Set();\r\n    const add = i => { const n = Number(i); if (Number.isInteger(n) && n>=0 && n<=47) out.add(n); };\r\n    const addRange = (a,b) => { let x=+a,y=+b; if (!Number.isFinite(x)||!Number.isFinite(y)) return;\r\n        const s=Math.max(0,Math.min(x,y)), e=Math.min(47,Math.max(x,y)); for (let i=s;i<=e;i++) add(i); };\r\n    const walk = v => {\r\n        if (v==null) return;\r\n        if (typeof v==='number') return add(v);\r\n        if (typeof v==='string') { const s=v.trim(); const m=s.match(/^(\\d{1,2})\\s*-\\s*(\\d{1,2})$/); if (m) return addRange(m[1],m[2]); if (s.toLowerCase()==='all') return addRange(0,47); return add(s); }\r\n        if (Array.isArray(v)) { if (v.length===2 && v.every(x=>Number.isFinite(+x))) return addRange(v[0],v[1]); for (const x of v) walk(x); return; }\r\n        if (typeof v==='object') for (const k of Object.keys(v)) walk(v[k]);\r\n    };\r\n    walk(raw);\r\n    return [...out].sort((a,b)=>a-b);\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\storage\\mongoose.js": "import mongoosePkg from 'mongoose';\r\n\r\nexport async function createMongooseAdapter({ mongoUrl, dbName = 'pizza25', connect = false, debug = 0, mongoose = null }) {\r\n    const m = mongoose || mongoosePkg;\r\n\r\n    if (connect) {\r\n        if (m.connection.readyState === 0) {\r\n            await m.connect(mongoUrl, { dbName, serverSelectionTimeoutMS: 1500 }).catch(() => {});\r\n        }\r\n    }\r\n    const ready = async () => m?.connection?.readyState === 1;\r\n\r\n    const AddressSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        addressFull: { type:String, required:true },\r\n        addressJSON: { type:m.Schema.Types.Mixed, required:true },\r\n        createdAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    AddressSchema.index({ userId:1, addressFull:1 }, { unique:true });\r\n\r\n    const PhoneSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        phone: { type:String, required:true },\r\n        isPrimary: { type:Boolean, default:false },\r\n        createdAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    PhoneSchema.index({ userId:1, phone:1 }, { unique:true });\r\n\r\n    const CartSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        items: [{\r\n            id: { type:String, required:true },\r\n            name:{ type:String, required:true },\r\n            cost:{ type:Number, required:true },\r\n            count:{ type:Number, required:true }\r\n        }],\r\n        updatedAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    CartSchema.index({ userId:1 }, { unique:true });\r\n\r\n    const MenuOrderSchema = new m.Schema({\r\n        parentId:   { type:String, index:true, default:null },\r\n        orderedIds: { type:[String], default:[] },\r\n        hiddenIds:  { type:[String], default:[] },\r\n        updatedAt:  { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    MenuOrderSchema.index({ parentId:1 }, { unique:true });\r\n\r\n    const models = m.connection.models;\r\n    const Address   = models.TelegramAddress || m.model('TelegramAddress', AddressSchema);\r\n    const Phone     = models.TelegramPhone   || m.model('TelegramPhone',   PhoneSchema);\r\n    const Cart      = models.TelegramCart    || m.model('TelegramCart',    CartSchema);\r\n    const MenuOrder = models.MenuOrder       || m.model('MenuOrder',       MenuOrderSchema);\r\n\r\n    return {\r\n        ready,\r\n        async getAddresses(userId, limit = 6) {\r\n            if (!await ready()) return [];\r\n            return Address.find({ userId }).sort({ createdAt:-1 }).limit(limit).lean().exec();\r\n        },\r\n        async saveAddress(userId, addressFull, addressJSON) {\r\n            if (!await ready()) return;\r\n            await Address.updateOne({ userId, addressFull }, { $setOnInsert: { addressJSON, createdAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n        },\r\n        async savePhone(userId, phone, isPrimary=false) {\r\n            if (!await ready()) return;\r\n            await Phone.updateOne({ userId, phone }, { $setOnInsert: { isPrimary, createdAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n            if (isPrimary) await Phone.updateMany({ userId, phone: { $ne: phone } }, { $set: { isPrimary:false } }).exec().catch(()=>{});\r\n        },\r\n        async loadCart(userId) {\r\n            if (!await ready()) return [];\r\n            const doc = await Cart.findOne({ userId }).lean().exec();\r\n            return Array.isArray(doc?.items) ? doc.items : [];\r\n        },\r\n        async saveCart(userId, items) {\r\n            if (!await ready()) return;\r\n            await Cart.updateOne({ userId }, { $set: { items: Array.isArray(items) ? items : [], updatedAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n        },\r\n        async loadAllMenuOrders() {\r\n            if (!await ready()) return [];\r\n            return MenuOrder.find({}).lean().exec();\r\n        },\r\n        async saveMenuOrder(parentId, orderedIds=[], hiddenIds=[]) {\r\n            if (!await ready()) return;\r\n            await MenuOrder.updateOne({ parentId: parentId == null ? null : String(parentId) },\r\n                { $set: { orderedIds: orderedIds.map(String), hiddenIds: hiddenIds.map(String), updatedAt:new Date() } },\r\n                { upsert:true }).exec().catch(()=>{});\r\n        }\r\n    };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\storage\\types.js": "/**\r\n * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –¥–ª—è –¥–≤–∏–∂–∫–∞ (–≤–∞—Ä–∏–∞–Ω—Ç 4). –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Redis/Postgres/—á—Ç–æ —É–≥–æ–¥–Ω–æ.\r\n * –í—Å–µ –º–µ—Ç–æ–¥—ã ‚Äî –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ.\r\n *\r\n * export type Storage = {\r\n *   ready(): Promise<boolean>,\r\n *   getAddresses(userId:number, limit?:number): Promise<any[]>,\r\n *   saveAddress(userId:number, addressFull:string, addressJSON:any): Promise<void>,\r\n *   savePhone(userId:number, phone:string, isPrimary?:boolean): Promise<void>,\r\n *   loadCart(userId:number): Promise<Array<{id:string,name:string,cost:number,count:number}>>,\r\n *   saveCart(userId:number, items:Array<{id:string,name:string,cost:number,count:number}>): Promise<void>,\r\n *   loadAllMenuOrders(): Promise<Array<{parentId:string|null, orderedIds:string[], hiddenIds:string[]}>>,\r\n *   saveMenuOrder(parentId:string|null, orderedIds:string[], hiddenIds:string[]): Promise<void>\r\n * }\r\n */\r\nexport {};\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\util-date.js": "// –í—Ä–µ–º—è –∏ —Å–ª–æ—Ç—ã: —Ç–æ–ª—å–∫–æ Intl API. –ò—Å—Ç–æ—á–Ω–∏–∫ –ø–æ–¥—Ö–æ–¥–∞: –≤–∞—Ä–∏–∞–Ω—Ç—ã 3/4. (–±–µ–∑ luxon)\r\nfunction toTZParts(date, timeZone) {\r\n    const fmt = new Intl.DateTimeFormat('ru-RU', {\r\n        timeZone, year:'numeric', month:'2-digit', day:'2-digit',\r\n        hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false\r\n    });\r\n    const parts = Object.fromEntries(fmt.formatToParts(date).map(p => [p.type, p.value]));\r\n    return {\r\n        y: +parts.year, m:+parts.month, d:+parts.day,\r\n        H:+parts.hour, M:+parts.minute, S:+parts.second\r\n    };\r\n}\r\n\r\nexport function nowTZMinutesSinceMidnight(timeZone) {\r\n    const p = toTZParts(new Date(), timeZone);\r\n    return p.H * 60 + p.M;\r\n}\r\n\r\nexport function slotLabel(halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    if (!Number.isInteger(idx) || idx < 0 || idx > 47) return '‚Äî';\r\n    const start = 30 + idx * 30;\r\n    const h = Math.floor(start / 60), m = start % 60;\r\n    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;\r\n}\r\n\r\nexport function toLocalPrestoDate(dateStr, halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    const base = 30 + (Number.isInteger(idx) ? idx * 30 : 0);\r\n    const h = Math.floor(base / 60), m = base % 60;\r\n    return `${dateStr} ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`;\r\n}\r\n\r\nexport function isTodayInTZ(isoYYYYMMDD, timeZone) {\r\n    const p = toTZParts(new Date(), timeZone);\r\n    const s = `${String(p.y).padStart(4,'0')}-${String(p.m).padStart(2,'0')}-${String(p.d).padStart(2,'0')}`;\r\n    return s === isoYYYYMMDD;\r\n}\r\n\r\nexport function humanDateShort(isoYYYYMMDD, timeZone) {\r\n    const [Y,M,D] = isoYYYYMMDD.split('-').map(Number);\r\n    const dt = new Date(Date.UTC(Y, M - 1, D));\r\n    return new Intl.DateTimeFormat('ru-RU', { timeZone, day:'2-digit', month:'2-digit', weekday:'short' })\r\n        .format(dt).replace(',', '');\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\test.js": "// test.js ‚Äî Telegram-–±–æ—Ç –Ω–∞ Saby Presto\r\n// ES-–º–æ–¥—É–ª–∏. Reply keyboard –¥–ª—è –≤–µ—Ä—Ö–Ω–∏—Ö —Ä–∞–∑–¥–µ–ª–æ–≤. Inline ‚Äî –¥–ª—è –ø–æ–∑–∏—Ü–∏–π –∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.\r\n// –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –∫–∞—Ç–∞–ª–æ–≥–∞–º:\r\n//  ‚Ä¢ –ï—Å–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤, –Ω–æ –µ—Å—Ç—å –ø–æ–¥–ø–∞–ø–∫–∏ ‚Üí –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ –≤ –ø–µ—Ä–≤—É—é –ø–æ–¥–ø–∞–ø–∫—É –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –∞–¥–º–∏–Ω–æ–º –ø–æ—Ä—è–¥–∫—É.\r\n//  ‚Ä¢ –í –∫–æ–Ω—Ü–µ —Å–ø–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É: ‚Üê –ø—Ä–µ–¥—ã–¥—É—â–∏–π | –ù–∞–∑–∞–¥ | —Å–ª–µ–¥—É—é—â–∏–π ‚Üí\r\n//    - ¬´–ù–∞–∑–∞–¥¬ª –≤–µ–¥—ë—Ç –Ω–∞ —É—Ä–æ–≤–µ–Ω—å —Ä–æ–¥–∏—Ç–µ–ª—è; –µ—Å–ª–∏ –º—ã –Ω–∞ –≤–µ—Ä—Ö–Ω–µ–º —É—Ä–æ–≤–Ω–µ ‚Äî –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º ¬´–ù–∞–∑–∞–¥¬ª –≤–æ–≤—Å–µ.\r\n// –†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –¥–ª—è —Å—É–ø–µ—Ä-–∞–¥–º–∏–Ω–∞ (tgId 674870519): /sort. –•—Ä–∞–Ω–∏–º –ø–æ—Ä—è–¥–æ–∫ –∏ —Å–∫—Ä—ã—Ç–æ—Å—Ç—å –≤ Mongo.\r\n\r\nimport { DateTime } from 'luxon';\r\nimport {\r\n    dbInit,\r\n    dbGetAddresses,\r\n    dbSaveAddress,\r\n    dbSavePhone,\r\n    dbLoadCart,\r\n    dbSaveCart,\r\n    dbLoadAllMenuOrders,\r\n    dbSaveMenuOrder,\r\n    generateStableUuid,\r\n    normalizeCalendarIntervals\r\n} from './bd.js';\r\n\r\n// ====== –ö–û–ù–§–ò–ì ======\r\nconst CLIENT_ID   = \"0872375115278704\";\r\nconst SECRET_KEY  = \"UOAOFCJHX5VSEUHOYUJUUTDS\";\r\nconst SERVICE_KEY = \"LOc3JFMCazGkz3EaEtFcQV9FpEfodaDoDMGkTkFw6TROVtzWYApoPj37eJ1cVP5nS5xm8hlHJsq6e5YXee4MDsFCDyiVZ628lUi92oJn4WQWBKMrfdNmuW\";\r\n\r\nconst AUTH_URL    = \"https://online.sbis.ru/oauth/service/\";\r\nconst API_BASE    = \"https://api.sbis.ru\";\r\nconst RETAIL_BASE = `${API_BASE}/retail`;\r\n\r\nconst BOT_API     = \"7561802884:AAF8mh3OGofmDbnrVfDdYLeJrFT6j_aZf4s\";\r\n\r\n// ====== DEBUG ======\r\nconst DEBUG = 2;\r\nconst dbg  = (...a) => { if (DEBUG >= 1) console.log(\"[DBG]\", ...a); };\r\nconst vdbg = (...a) => { if (DEBUG >= 2) console.log(\"[DBG2]\", ...a); };\r\nconst short = (obj, max = 400) => { try { const s = JSON.stringify(obj); return s.length > max ? s.slice(0, max) + \"‚Ä¶\" : s; } catch { return String(obj); } };\r\n\r\n// ====== –ú–ï–ù–Æ/–í–ò–¢–†–ò–ù–ê ======\r\nconst FIXED_PRICE_LIST_ID = 64;               // –ë–∞—Ä –æ—Å–Ω–æ–≤–Ω–æ–π\r\nconst FIXED_PRICE_LIST_NAME = \"–ë–∞—Ä –æ—Å–Ω–æ–≤–Ω–æ–π\";\r\nconst DEFAULT_MENU_PAGE_SIZE = 12;\r\nconst ADMIN_ID = 674870519;\r\n\r\nconst SHOP_URL    = \"https://pizza25.ru\";\r\nconst SUCCESS_URL = \"https://pizza25.ru/pay/success\";\r\nconst ERROR_URL   = \"https://pizza25.ru/pay/error\";\r\n\r\n// ====== –°–õ–û–¢–´ –î–û–°–¢–ê–í–ö–ò ======\r\nconst BUSINESS_TZ    = 'Asia/Vladivostok';\r\nconst SLOT_OPEN_IDX  = 20;\r\nconst SLOT_CLOSE_IDX = 42;\r\n\r\n// ====== TELEGRAM API ======\r\nconst TG_API = `https://api.telegram.org/bot${BOT_API}`;\r\nlet UPDATE_OFFSET = 0;\r\n\r\n// ====== STATE ======\r\nconst STATE = new Map(); // chatId -> user session\r\n\r\n// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã\r\nconst SABY = { token: null, sid: null };\r\nlet POINT_ID = null;\r\nlet PRICE_LISTS = [];\r\nlet CATALOG = null;\r\n\r\n// –ü–æ—Ä—è–¥–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: Map<parentId|null, {order:string[], hidden:Set<string>}>\r\nconst CATEGORY_ORDER = new Map();\r\n\r\n// ====== helpers ======\r\nconst encId = id => Buffer.from(String(id), \"utf8\").toString(\"base64url\");\r\nconst decId = s  => { try { return Buffer.from(String(s), \"base64url\").toString(\"utf8\"); } catch { return String(s); } };\r\n\r\nfunction getState(chatId) {\r\n    if (!STATE.has(chatId)) STATE.set(chatId, { cart: [], cartLoaded: false });\r\n    const st = STATE.get(chatId);\r\n    if (!Array.isArray(st.cart)) st.cart = [];\r\n    if (typeof st.cartLoaded !== 'boolean') st.cartLoaded = false;\r\n    if (!st.currentPriceListId) st.currentPriceListId = FIXED_PRICE_LIST_ID;\r\n    if (!st.currentPriceListName) st.currentPriceListName = FIXED_PRICE_LIST_NAME;\r\n    return st;\r\n}\r\nasync function ensureCartLoaded(chatId) {\r\n    const st = getState(chatId);\r\n    if (st.cartLoaded) return st;\r\n    try {\r\n        const items = await dbLoadCart(chatId);\r\n        if (Array.isArray(items) && items.length) {\r\n            st.cart = items.map(x => ({ ...x, id: String(x.id) }));\r\n        }\r\n    } catch {}\r\n    st.cartLoaded = true;\r\n    return st;\r\n}\r\nfunction cartSummary(st, previewLimit = 3) {\r\n    const total = st.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n    const count = st.cart.reduce((s, r) => s + r.count, 0);\r\n    const lines = st.cart.map(r => `‚Ä¢ ${r.name} √ó ${r.count} = ${priceLabel(r.cost * r.count)}`);\r\n    const preview = lines.slice(0, previewLimit);\r\n    if (lines.length > previewLimit) preview.push(`‚Ä¶ –µ—â—ë ${lines.length - previewLimit}`);\r\n    return { total, count, lines, preview };\r\n}\r\nconst priceLabel = v => `${(Number(v) || 0).toFixed(0)} ‚ÇΩ`;\r\n\r\nconst rk = rows => ({ reply_markup: JSON.stringify({ keyboard: rows, resize_keyboard: true, one_time_keyboard: false }) });\r\nconst ik = rows => ({ reply_markup: JSON.stringify({ inline_keyboard: rows }) });\r\n\r\nfunction toLocalPrestoDate(dateStr, halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    const base = 30 + (Number.isInteger(idx) ? idx * 30 : 0);\r\n    const h = Math.floor(base / 60), m = base % 60;\r\n    return `${dateStr} ${String(h).padStart(2, \"0\")}:${String(m).padStart(2, \"0\")}:00`;\r\n}\r\nfunction slotLabel(halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    if (!Number.isInteger(idx) || idx < 0 || idx > 47) return \"‚Äî\";\r\n    const startMinutes = 30 + idx * 30;\r\n    const h = Math.floor(startMinutes / 60);\r\n    const m = startMinutes % 60;\r\n    return `${String(h).padStart(2, \"0\")}:${String(m).padStart(2, \"0\")}`;\r\n}\r\nfunction normalizePhone(s) {\r\n    if (!s) return null;\r\n    let p = String(s).replace(/[^\\d+]/g, \"\");\r\n    if (/^8\\d{10}$/.test(p)) return `+7${p.slice(1)}`;\r\n    if (/^\\+7\\d{10}$/.test(p)) return p;\r\n    if (/^7\\d{10}$/.test(p)) return `+${p}`;\r\n    return null;\r\n}\r\n\r\n// ====== SABY CALLS ======\r\nasync function sabyAuth() {\r\n    const res = await fetch(AUTH_URL, {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json; charset=utf-8\", \"Accept\": \"application/json\" },\r\n        body: JSON.stringify({ app_client_id: CLIENT_ID, app_secret: SECRET_KEY, secret_key: SERVICE_KEY })\r\n    });\r\n    if (!res.ok) throw new Error(`Saby auth failed: ${res.status}`);\r\n    const data = await res.json();\r\n    SABY.token = data.token; SABY.sid = data.sid;\r\n}\r\nfunction sabyHeaders() {\r\n    const h = { \"X-SBISAccessToken\": SABY.token };\r\n    if (SABY.sid) h[\"Cookie\"] = `sid=${SABY.sid}`;\r\n    return h;\r\n}\r\nasync function sabyFetch(url, opts = {}) {\r\n    const finalUrl = url instanceof URL ? url.toString() : String(url);\r\n    const res = await fetch(finalUrl, {\r\n        method: opts.method || \"GET\",\r\n        headers: { \"Accept\": \"application/json\", ...(opts.headers || {}), ...sabyHeaders() },\r\n        body: opts.body\r\n    });\r\n\r\n    if (res.status === 401) {\r\n        await sabyAuth();\r\n        return sabyFetch(url, opts);\r\n    }\r\n\r\n    const text = await res.text().catch(() => \"\");\r\n    if (!res.ok) {\r\n        throw new Error(`${finalUrl} ‚Üí ${res.status} ${text}`);\r\n    }\r\n\r\n    let data = null;\r\n    try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: text }; }\r\n    if (data && typeof data === \"object\" && data.error) {\r\n        throw new Error(`${finalUrl} ‚Üí RPC error ${short(data.error)}`);\r\n    }\r\n    return data;\r\n}\r\nasync function sabyGetPoints() { return sabyFetch(`${RETAIL_BASE}/point/list`); }\r\nasync function sabyGetPriceLists(pointId, actualDate = new Date()) {\r\n    const url = new URL(`${RETAIL_BASE}/nomenclature/price-list`);\r\n    url.searchParams.set(\"pointId\", String(pointId));\r\n    url.searchParams.set(\"actualDate\", `${actualDate.toLocaleDateString(\"ru-RU\")} ${actualDate.toLocaleTimeString(\"ru-RU\")}`);\r\n    url.searchParams.set(\"pageSize\", \"1000\");\r\n    return sabyFetch(url);\r\n}\r\nasync function sabyGetNomenclature(pointId, priceListId, page = 0, pageSize = 1000) {\r\n    const url = new URL(`${RETAIL_BASE}/nomenclature/list`);\r\n    url.searchParams.set(\"pointId\", String(pointId));\r\n    url.searchParams.set(\"priceListId\", String(priceListId));\r\n    url.searchParams.set(\"page\", String(page));\r\n    url.searchParams.set(\"pageSize\", String(pageSize));\r\n    return sabyFetch(url);\r\n}\r\nasync function sabySuggestedAddress(addressLine) {\r\n    const url = new URL(`${RETAIL_BASE}/delivery/suggested-address`);\r\n    url.searchParams.set(\"address\", addressLine);\r\n    return sabyFetch(url);\r\n}\r\nasync function sabyDeliveryCost(pointId, addressJSONorString) {\r\n    const url = new URL(`${RETAIL_BASE}/delivery/cost`);\r\n    url.searchParams.set(\"pointId\", String(pointId));\r\n    url.searchParams.set(\"address\", typeof addressJSONorString === \"string\" ? addressJSONorString : JSON.stringify(addressJSONorString));\r\n    return sabyFetch(url);\r\n}\r\nasync function sabyDeliveryCalendar(pointId, page = 0, pageSize = 7) {\r\n    const url = new URL(`${RETAIL_BASE}/delivery/calendar`);\r\n    url.searchParams.set(\"pointId\", String(pointId));\r\n    url.searchParams.set(\"page\", String(page));\r\n    url.searchParams.set(\"pageSize\", String(pageSize));\r\n    return sabyFetch(url);\r\n}\r\nasync function sabyCreateOrder(payload) {\r\n    return sabyFetch(`${RETAIL_BASE}/order/create`, {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json; charset=utf-8\" },\r\n        body: JSON.stringify(payload)\r\n    });\r\n}\r\nasync function sabyPaymentLink(externalId, { shopURL, successURL, errorURL } = { shopURL: SHOP_URL, successURL: SUCCESS_URL, errorURL: ERROR_URL }) {\r\n    const ext = String(externalId);\r\n    const url = new URL(`${RETAIL_BASE}/order/${encodeURIComponent(ext)}/payment-link`);\r\n    url.searchParams.set(\"externalId\", ext);\r\n    url.searchParams.set(\"shopURL\", shopURL);\r\n    if (successURL) url.searchParams.set(\"successURL\", successURL);\r\n    if (errorURL)   url.searchParams.set(\"errorURL\", errorURL);\r\n\r\n    const data = await sabyFetch(url, { method: \"GET\" });\r\n    if (!data || typeof data.link !== \"string\" || !data.link) {\r\n        throw new Error(`payment-link: –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç ${short(data)}`);\r\n    }\r\n    return data; // { link }\r\n}\r\nasync function sabyOrderState(externalId) {\r\n    const ext = encodeURIComponent(String(externalId));\r\n    const url = `${RETAIL_BASE}/order/${ext}/state`;\r\n    try {\r\n        return await sabyFetch(url);\r\n    } catch (e) {\r\n        const info = await sabyOrderInfo(externalId).catch(() => null);\r\n        if (!info) throw e;\r\n        const out = { state: Number(info?.state ?? info?.orderState ?? info?.status ?? NaN) };\r\n        if (Array.isArray(info?.payments)) out.payments = info.payments;\r\n        return out;\r\n    }\r\n}\r\nasync function sabyOrderInfo(externalId) {\r\n    const ext = encodeURIComponent(String(externalId));\r\n    return sabyFetch(`${RETAIL_BASE}/order/${ext}`);\r\n}\r\nasync function sabyRegisterPayment(externalId, {\r\n    cashSum = 0, bankSum = 0, salarySum = 0,\r\n    retailPlace = SHOP_URL, paymentType = \"full\", nonFiscal = false\r\n} = {}) {\r\n    const ext = encodeURIComponent(String(externalId));\r\n    const url = new URL(`${RETAIL_BASE}/order/${ext}/register-payment`);\r\n    url.searchParams.set(\"cashSum\", String(cashSum));\r\n    url.searchParams.set(\"bankSum\", String(bankSum));\r\n    url.searchParams.set(\"salarySum\", String(salarySum));\r\n    url.searchParams.set(\"retailPlace\", retailPlace);\r\n    url.searchParams.set(\"paymentType\", paymentType);\r\n    if (nonFiscal) url.searchParams.set(\"nonFiscal\", \"true\");\r\n    return sabyFetch(url, { method: \"GET\" });\r\n}\r\nasync function sabyCancelOrder(externalId) {\r\n    const ext = encodeURIComponent(String(externalId));\r\n    return sabyFetch(`${RETAIL_BASE}/order/${ext}/cancel`, { method: \"PUT\" });\r\n}\r\n\r\n// ====== –ö–ê–¢–ê–õ–û–ì ======\r\nfunction hasAnySeparator(s) { return /[./\\\\-]/.test(s || \"\"); }\r\nfunction normHierId(h) { if (h == null) return null; const s = String(h); return s.replace(/[\\/\\\\\\-]+/g, \".\").replace(/\\.+/g, \".\").replace(/^\\.+|\\.+$/g, \"\"); }\r\nfunction splitHierId(h) { const n = normHierId(h); return n ? n.split(\".\").filter(Boolean) : []; }\r\n\r\nfunction guessSegmentSize(rawHierList) {\r\n    const clean = rawHierList.map(x => String(x || \"\").trim()).filter(Boolean);\r\n    if (!clean.length) return null;\r\n    if (clean.some(hasAnySeparator)) return null;\r\n    let bestS = null, bestScore = -1;\r\n    for (let s = 2; s <= 6; s++) {\r\n        let parentCounts = Object.create(null);\r\n        let depthSum = 0, depthCnt = 0;\r\n        for (const h of clean) {\r\n            const depth = Math.floor(h.length / s);\r\n            if (depth >= 2) {\r\n                depthSum += depth; depthCnt++;\r\n                const parent = h.slice(0, (depth - 1) * s);\r\n                parentCounts[parent] = (parentCounts[parent] || 0) + 1;\r\n            }\r\n        }\r\n        const multiParents = Object.values(parentCounts).filter(x => x >= 2).length;\r\n        const avgDepth = depthCnt ? depthSum / depthCnt : 0;\r\n        const score = multiParents * 10 + avgDepth;\r\n        if (score > bestScore) { bestScore = score; bestS = multiParents ? s : bestS; }\r\n    }\r\n    return bestS;\r\n}\r\n\r\n// ====== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ù–û–ú–ï–ù–ö–õ–ê–¢–£–†–´/–ö–ê–¢–ê–õ–û–ì–ê ======\r\nfunction catDbg(...a){ if (DEBUG>=1) console.log(\"[CAT]\", ...a); }\r\nfunction catVDbg(...a){ if (DEBUG>=2) console.log(\"[CAT2]\", ...a); }\r\n\r\nfunction analyzeRawNomenclature(records) {\r\n    const stats = {\r\n        total: records.length,\r\n        withId: 0, withoutId: 0,\r\n        priceNum: 0, noPrice: 0,\r\n        withImages: 0,\r\n        hierWithSep: 0, hierNoSep: 0, hierNull: 0,\r\n        parentRawPresent: 0,\r\n        typeHintsFolder: 0\r\n    };\r\n    const sampleFields = new Set();\r\n    const typesSet = new Set();\r\n\r\n    for (const x of records) {\r\n        const id = x.id ?? x.externalId ?? x.nomNumber ?? x.nomenclatureId ?? x.key ?? null;\r\n        if (id==null) stats.withoutId++; else stats.withId++;\r\n\r\n        const costNum = Number(x.cost ?? x.price ?? x.priceWithDiscount ?? x.amount);\r\n        if (Number.isFinite(costNum)) stats.priceNum++; else stats.noPrice++;\r\n\r\n        if (Array.isArray(x.images) && x.images.length) stats.withImages++;\r\n\r\n        const hierRaw = x.hierarchicalId ?? x.hierarchyId ?? x.hid ?? x.path ?? null;\r\n        if (hierRaw==null) stats.hierNull++;\r\n        else if (/[./\\\\-]/.test(String(hierRaw))) stats.hierWithSep++;\r\n        else stats.hierNoSep++;\r\n\r\n        if (x.hierarchicalParent!=null) stats.parentRawPresent++;\r\n\r\n        const typeStr = String(x.type ?? x.nomenclatureType ?? \"\").toLowerCase();\r\n        if (/(group|folder|category)/.test(typeStr) || x.isParent || x.isGroup || x.isFolder || x.isCategory || x.hasChildren || (x.childrenCount>0)) {\r\n            stats.typeHintsFolder++;\r\n        }\r\n        Object.keys(x).forEach(k => sampleFields.add(k));\r\n        if (typeStr) typesSet.add(typeStr);\r\n    }\r\n    return { stats, sampleFields: [...sampleFields].slice(0,30), types: [...typesSet].slice(0,20) };\r\n}\r\n\r\nfunction dumpTreePreview(CATALOG, maxFolders=12, maxItemsPerFolder=5) {\r\n    const root = CATALOG.ROOT;\r\n    const roots = (CATALOG.foldersByParent.get(root)||[]).slice(0, maxFolders);\r\n    const lines = [];\r\n    lines.push(`ROOT folders: ${ (CATALOG.foldersByParent.get(root)||[]).length }, items: ${ (CATALOG.itemsByParent.get(root)||[]).length }`);\r\n    for (const fid of roots) {\r\n        const name = CATALOG.byId.get(fid)?.name || \"–ö–∞—Ç–∞–ª–æ–≥\";\r\n        const subF = (CATALOG.foldersByParent.get(fid)||[]).length;\r\n        const subI = (CATALOG.itemsByParent.get(fid)||[]).length;\r\n        lines.push(`‚Ä¢ ${name} ‚Äî –ø–∞–ø–æ–∫: ${subF}, —Ç–æ–≤–∞—Ä–æ–≤: ${subI}`);\r\n        const samp = (CATALOG.itemsByParent.get(fid)||[]).slice(0, maxItemsPerFolder);\r\n        for (const iid of samp) {\r\n            const it = CATALOG.byId.get(iid);\r\n            lines.push(`   - ${it?.name || it?.id} ‚Ä¢ ${Number.isFinite(it?.cost)? `${(it.cost).toFixed(0)} ‚ÇΩ`: \"‚Äî\"}`);\r\n        }\r\n    }\r\n    return lines.join(\"\\n\");\r\n}\r\n\r\n// ====== –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–±–æ—Ä–∫–∞ –∏–Ω–¥–µ–∫—Å–æ–≤ –∫–∞—Ç–∞–ª–æ–≥–∞ ======\r\nfunction buildCatalogIndexes(records) {\r\n    const { stats:rawStats, sampleFields, types } = analyzeRawNomenclature(records);\r\n    catDbg(\"[raw] total:\", rawStats.total, \"| ids:\", rawStats.withId, \"/\", rawStats.total, \"| price:\", rawStats.priceNum, \"/\", rawStats.total);\r\n    catVDbg(\"[raw] fields:\", sampleFields.join(\", \"));\r\n    catVDbg(\"[raw] type strings sample:\", types.join(\", \"));\r\n\r\n    const prepared = records.map((x, idx) => {\r\n        const name = x.name ?? x.title ?? x.caption ?? \"–ü–æ–∑–∏—Ü–∏—è\";\r\n        const costNum = Number(x.cost ?? x.price ?? x.priceWithDiscount ?? x.amount);\r\n        const hasCost = Number.isFinite(costNum);\r\n        const hierRaw = x.hierarchicalId ?? x.hierarchyId ?? x.hid ?? x.path ?? null;\r\n        const hierParentRaw = x.hierarchicalParent ?? null;\r\n        const indexNumber = Number.isFinite(Number(x.indexNumber)) ? Number(x.indexNumber) : null;\r\n        const idCandidate = x.id ?? x.externalId ?? x.nomNumber ?? x.nomenclatureId ?? x.key ?? null;\r\n        const id = idCandidate != null ? String(idCandidate) : null;\r\n\r\n        const typeStr = String(x.type ?? x.nomenclatureType ?? \"\").toLowerCase();\r\n        const isFolderFlag = !!(x.isParent || x.isGroup || x.isFolder || x.isCategory || x.hasChildren || x.childrenCount > 0\r\n            || /(group|folder|category)/.test(typeStr) || !hasCost);\r\n\r\n        return {\r\n            raw: x, id, name,\r\n            hasCost, costNum,\r\n            hierRaw, hierParentRaw,\r\n            orderIdx: indexNumber ?? idx,\r\n            isFolder: isFolderFlag,\r\n            images: Array.isArray(x.images) ? x.images.map(q => `https://api.sbis.ru/retail${q}`) : []\r\n        };\r\n    });\r\n\r\n    // –°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è (–µ—Å–ª–∏ –Ω–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π)\r\n    const rawHiers = prepared.map(p => p.hierRaw).filter(Boolean);\r\n    const forcedSeg = Number(process.env.FORCE_SEGMENT_SIZE || NaN);\r\n    const guessedSeg = Number.isInteger(forcedSeg) ? forcedSeg : guessSegmentSize(rawHiers);\r\n    catDbg(`[seg] FORCE=${Number.isInteger(forcedSeg)? forcedSeg : \"‚Äî\"}, guessed=${guessedSeg || \"‚Äî\"}`);\r\n\r\n    for (const p of prepared) {\r\n        let hierNorm = normHierId(p.hierRaw);\r\n        if (guessedSeg && hierNorm && !/[./\\\\-]/.test(hierNorm)) {\r\n            const parts = []; const s = String(hierNorm); for (let i = 0; i < s.length; i += guessedSeg) parts.push(s.slice(i, i + guessedSeg));\r\n            hierNorm = parts.join(\".\");\r\n        }\r\n        p.hierNorm = hierNorm;\r\n    }\r\n\r\n    const ROOT = null;\r\n    const byId = new Map();\r\n    const parentById = new Map();\r\n    const foldersByParent = new Map();\r\n    const itemsByParent = new Map();\r\n    const folderIdByExactPath = new Map();\r\n    const folderIdByHierRaw  = new Map();\r\n\r\n    function ensureFolder(node) { byId.set(node.id, node); }\r\n    function push(map, key, val) { const arr = map.get(key) || []; arr.push(val); map.set(key, arr); }\r\n\r\n    const path2ids = new Map(); // –¥–ª—è –ª–æ–≤–ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤\r\n\r\n    // –ü–∞–ø–∫–∏\r\n    for (const p of prepared.filter(p => p.isFolder)) {\r\n        let id = p.id;\r\n        if (!id) {\r\n            const norm = p.hierNorm ?? String(p.hierRaw ?? \"\");\r\n            if (!norm) continue; // –ø–∞–ø–∫–∞ –±–µ–∑ id –∏ –ø—É—Ç–∏ ‚Äî –ø—Ä–æ–ø—É—Å–∫\r\n            id = `__cat__:${norm}`;\r\n        }\r\n        id = String(id);\r\n        const node = { id, name: p.name, cost: NaN, images: p.images, hier: p.hierNorm, folder: true, raw: p.raw, orderIdx: p.orderIdx };\r\n        ensureFolder(node);\r\n\r\n        if (p.hierNorm) {\r\n            folderIdByExactPath.set(p.hierNorm, id);\r\n            const arr = path2ids.get(p.hierNorm) || [];\r\n            arr.push(id); path2ids.set(p.hierNorm, arr);\r\n        }\r\n        if (p.hierRaw  != null) folderIdByHierRaw.set(String(p.hierRaw), id);\r\n\r\n        let pid = null;\r\n        if (p.hierParentRaw != null) pid = folderIdByHierRaw.get(String(p.hierParentRaw)) ?? null;\r\n        if (!pid && p.hierNorm) {\r\n            const parts = splitHierId(p.hierNorm);\r\n            pid = parts.length > 1 ? folderIdByExactPath.get(parts.slice(0, -1).join(\".\")) ?? ROOT : ROOT;\r\n        }\r\n        parentById.set(id, pid ?? ROOT);\r\n    }\r\n\r\n    // –¢–æ–≤–∞—Ä—ã\r\n    for (const p of prepared.filter(p => !p.isFolder)) {\r\n        if (!p.id) continue; // —Ç–æ–≤–∞—Ä –±–µ–∑ id ‚Äî –ø—Ä–æ–ø—É—Å–∫\r\n        const node = { id: String(p.id), name: p.name, cost: p.hasCost ? p.costNum : NaN, images: p.images, hier: p.hierNorm, folder: false, raw: p.raw, orderIdx: p.orderIdx };\r\n        byId.set(node.id, node);\r\n\r\n        let pid = null;\r\n        if (p.hierParentRaw != null) pid = folderIdByHierRaw.get(String(p.hierParentRaw)) ?? null;\r\n        if (!pid && p.hierNorm) {\r\n            const parts = splitHierId(p.hierNorm);\r\n            if (parts.length) {\r\n                const exact = folderIdByExactPath.get(parts.join(\".\"));\r\n                pid = exact ?? (parts.length > 1 ? folderIdByExactPath.get(parts.slice(0, -1).join(\".\")) ?? ROOT : ROOT);\r\n            }\r\n        }\r\n        parentById.set(node.id, pid ?? ROOT);\r\n    }\r\n\r\n    // –°–ø–∏—Å–∫–∏ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—è–º\r\n    for (const [id, pid] of parentById.entries()) {\r\n        const n = byId.get(id); if (!n) continue;\r\n        if (n.folder) push(foldersByParent, pid ?? ROOT, id);\r\n        else          push(itemsByParent,   pid ?? ROOT, id);\r\n    }\r\n\r\n    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞\r\n    const ord = id => byId.get(id)?.orderIdx ?? Number.MAX_SAFE_INTEGER;\r\n    const nameOf = id => (byId.get(id)?.name || \"\").toString().toLowerCase();\r\n    for (const [k, arr] of foldersByParent.entries()) arr.sort((a, b) => (ord(a) - ord(b)) || nameOf(a).localeCompare(nameOf(b)));\r\n    for (const [k, arr] of itemsByParent.entries())   arr.sort((a, b) => (ord(a) - ord(b)) || nameOf(a).localeCompare(nameOf(b)));\r\n\r\n    // ===== –ü—Ä–æ–≤–µ—Ä–∫–∏ & –æ—Ç—á—ë—Ç =====\r\n    // –ö–æ–Ω—Ñ–ª–∏–∫—Ç—ã –ø—É—Ç–µ–π (–Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–¥ –¥–ª—è –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ path)\r\n    const pathConflicts = [...path2ids.entries()].filter(([, ids]) => ids.length > 1);\r\n    if (pathConflicts.length) {\r\n        catDbg(`[conflict] ${pathConflicts.length} –∫–æ–Ω—Ñ–ª–∏–∫—Ç(–∞) path->ids`);\r\n        for (const [p, ids] of pathConflicts.slice(0, 10)) catVDbg(\"  path\", p, \"ids\", ids);\r\n    }\r\n\r\n    // –û—Å–∏—Ä–æ—Ç–µ–≤—à–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã\r\n    let orphans = 0;\r\n    for (const [id, pid] of parentById.entries()) {\r\n        const node = byId.get(id);\r\n        if (!node) continue;\r\n        if (node.hier) {\r\n            const depth = splitHierId(node.hier).length;\r\n            if (depth > 1 && (pid === ROOT || pid == null)) {\r\n                orphans++;\r\n                if (orphans <= 15) catVDbg(\"[orphan]\", node.folder? \"folder\":\"item\", id, node.name, \"hier:\", node.hier);\r\n            }\r\n        }\r\n    }\r\n    if (orphans) catDbg(`[orphans] –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º: ${orphans}`);\r\n\r\n    // –°–≤–æ–¥–∫–∞\r\n    const foldersCnt = [...byId.values()].filter(n => n.folder).length;\r\n    const itemsCnt   = [...byId.values()].filter(n => !n.folder).length;\r\n    catDbg(`[built] nodes: ${foldersCnt} –ø–∞–ø–æ–∫ + ${itemsCnt} —Ç–æ–≤–∞—Ä–æ–≤`);\r\n    catVDbg(\"\\n\" + dumpTreePreview({byId, parentById, foldersByParent, itemsByParent, ROOT}));\r\n\r\n    return { byId, parentById, foldersByParent, itemsByParent, ROOT };\r\n}\r\n\r\n// ====== –ü–æ—Ä—è–¥–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π ======\r\nfunction loadOrdersToMap(ordersArr) {\r\n    CATEGORY_ORDER.clear();\r\n    for (const doc of ordersArr) {\r\n        const pid = doc.parentId == null ? null : String(doc.parentId);\r\n        const order = Array.isArray(doc.orderedIds) ? doc.orderedIds.map(String) : [];\r\n        const hidden = new Set(Array.isArray(doc.hiddenIds) ? doc.hiddenIds.map(String) : []);\r\n        CATEGORY_ORDER.set(pid, { order, hidden });\r\n    }\r\n}\r\n// –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: –ø–æ—Ä—è–¥–æ–∫ + —Ñ–∏–ª—å—Ç—Ä —Å–∫—Ä—ã—Ç—ã—Ö\r\nfunction applyOrder(ids, parentId) {\r\n    const cfg = CATEGORY_ORDER.get(parentId == null ? null : String(parentId));\r\n    if (!cfg) return ids.slice();\r\n    const { order, hidden } = cfg;\r\n    const set = new Set(ids.map(String));\r\n    const inOrder = order.filter(id => set.has(String(id)));\r\n    const leftovers = ids.filter(id => !inOrder.includes(String(id)));\r\n    const res = [...inOrder, ...leftovers];\r\n    return res.filter(id => !hidden.has(String(id)));\r\n}\r\n// –¥–ª—è UI —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –ø–æ—Ä—è–¥–æ–∫ –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞ —Å–∫—Ä—ã—Ç—ã—Ö\r\nfunction getOrderedAll(idsBase, parentId) {\r\n    const cfg = CATEGORY_ORDER.get(parentId == null ? null : String(parentId));\r\n    if (!cfg) return idsBase.slice();\r\n    const { order } = cfg;\r\n    const set = new Set(idsBase.map(String));\r\n    const inOrder = order.filter(id => set.has(String(id)));\r\n    const leftovers = idsBase.filter(id => !inOrder.includes(String(id)));\r\n    return [...inOrder, ...leftovers];\r\n}\r\nasync function saveOrder(parentId, orderedIds) {\r\n    const pid = parentId == null ? null : String(parentId);\r\n    const prev = CATEGORY_ORDER.get(pid) || { order: [], hidden: new Set() };\r\n    const hiddenArr = [...prev.hidden];\r\n    await dbSaveMenuOrder(pid, orderedIds.map(String), hiddenArr);\r\n    CATEGORY_ORDER.set(pid, { order: orderedIds.map(String), hidden: new Set(hiddenArr) });\r\n}\r\n\r\n// ====== TELEGRAM API ======\r\nasync function tg(method, payload) {\r\n    const res = await fetch(`${TG_API}/${method}`, {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(payload)\r\n    });\r\n    if (!res.ok) {\r\n        const t = await res.text().catch(() => \"\");\r\n        throw new Error(`TG ${method} failed: ${res.status} ${t}`);\r\n    }\r\n    return res.json();\r\n}\r\nconst __ACKED = new Set();\r\nasync function answerCbSafe(cb, text = null, showAlert = false) {\r\n    if (!cb || !cb.id || __ACKED.has(cb.id)) return;\r\n    try {\r\n        const payload = { callback_query_id: cb.id };\r\n        if (text) payload.text = text;\r\n        if (showAlert) payload.show_alert = true;\r\n        await tg(\"answerCallbackQuery\", payload);\r\n    } catch {\r\n    } finally {\r\n        __ACKED.add(cb.id);\r\n    }\r\n}\r\n\r\n// ====== UI –ø–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–∏ ======\r\nfunction buildMainCategories() {\r\n    const root = CATALOG.ROOT;\r\n    const base = (CATALOG.foldersByParent.get(root) || []).slice();\r\n    const ordered = applyOrder(base, null);\r\n    return ordered.map(fid => {\r\n        const n = CATALOG.byId.get(fid);\r\n        return { id: fid, name: n?.name || \"–ö–∞—Ç–∞–ª–æ–≥\" };\r\n    });\r\n}\r\nfunction buildMainReplyKeyboard(mainCategories) {\r\n    const rows = [];\r\n    let buf = [];\r\n    for (const cat of mainCategories) {\r\n        buf.push({ text: cat.name });\r\n        if (buf.length === 3) { rows.push(buf); buf = []; }\r\n    }\r\n    if (buf.length) rows.push(buf);\r\n    rows.push([{ text: \"üìã –ú–µ–Ω—é\" }, { text: \"üß∫ –ö–æ—Ä–∑–∏–Ω–∞\" }, { text: \"üöö –î–æ—Å—Ç–∞–≤–∫–∞\" }]);\r\n    return rk(rows);\r\n}\r\nfunction siblingNavRow(currentFolderId) {\r\n    const parentId = CATALOG.parentById.get(currentFolderId) ?? CATALOG.ROOT;\r\n\r\n    const siblingsBase = (CATALOG.foldersByParent.get(parentId) || []).slice();\r\n    const siblings = applyOrder(siblingsBase, parentId == null ? null : parentId);\r\n    const idx = siblings.findIndex(x => String(x) === String(currentFolderId));\r\n    if (idx < 0) return null;\r\n\r\n    const prev = idx > 0 ? siblings[idx - 1] : null;\r\n    const next = idx < siblings.length - 1 ? siblings[idx + 1] : null;\r\n\r\n    const row = [];\r\n\r\n    if (prev) {\r\n        row.push({\r\n            text: `‚Üê ${CATALOG.byId.get(prev)?.name || \"–ü—Ä–µ–¥—ã–¥—É—â–∏–π\"}`,\r\n            callback_data: `cat:${encId(prev)}:0`\r\n        });\r\n    }\r\n\r\n    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ ¬´–Ω–∞–∑–∞–¥¬ª ‚Äî —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è\r\n    const parentItems = CATALOG.itemsByParent.get(parentId);\r\n    const hasItemsInParent = Array.isArray(parentItems) && parentItems.length > 0;\r\n\r\n    if (parentId != null && hasItemsInParent) {\r\n        const parentName = (CATALOG.byId.get(parentId)?.name || \"\").trim();\r\n        const shortName = parentName.length > 6 ? parentName.slice(0, 6) + \"‚Ä¶\" : parentName;\r\n        const backLabel = shortName ? `‚á¶ ${shortName}` : \"‚á¶ –ù–∞–∑–∞–¥\";\r\n\r\n        row.push({\r\n            text: backLabel,\r\n            callback_data: `back:${encId(parentId)}`\r\n        });\r\n    }\r\n\r\n    if (next) {\r\n        row.push({\r\n            text: `${CATALOG.byId.get(next)?.name || \"–°–ª–µ–¥—É—é—â–∏–π\"} ‚Üí`,\r\n            callback_data: `cat:${encId(next)}:0`\r\n        });\r\n    }\r\n\r\n    return row.length ? row : null;\r\n}\r\n\r\n// ====== –¢–û–í–ê–†–´/–ú–ï–ù–Æ ======\r\nasync function addToCart(chatId, itemId) {\r\n    await ensureCartLoaded(chatId);\r\n\r\n    const key = String(itemId);\r\n    const node = CATALOG?.byId?.get(key);\r\n    if (!node || node.folder) return { added: false };\r\n\r\n    const st = getState(chatId);\r\n    const cost = Number.isFinite(node.cost) ? node.cost : 0;\r\n    const row = st.cart.find(r => String(r.id) === key);\r\n\r\n    if (row) row.count += 1;\r\n    else st.cart.push({ id: key, name: node.name, cost, count: 1 });\r\n\r\n    await dbSaveCart(chatId, st.cart).catch(() => {});\r\n    const sum = cartSummary(st);\r\n    return { added: true, name: node.name, total: sum.total, count: sum.count };\r\n}\r\nasync function changeCartQty(chatId, itemId, delta) {\r\n    const st = await ensureCartLoaded(chatId);\r\n    const idx = st.cart.findIndex(r => String(r.id) === String(itemId));\r\n    if (idx < 0) return;\r\n    st.cart[idx].count = Math.max(1, Number(st.cart[idx].count || 1) + delta);\r\n    await dbSaveCart(chatId, st.cart).catch(() => {});\r\n}\r\nasync function deleteCartItem(chatId, itemId) {\r\n    const st = await ensureCartLoaded(chatId);\r\n    const before = st.cart.length;\r\n    st.cart = st.cart.filter(r => String(r.id) !== String(itemId));\r\n    if (st.cart.length !== before) await dbSaveCart(chatId, st.cart).catch(() => {});\r\n}\r\nasync function showCart(chatId) {\r\n    const st = await ensureCartLoaded(chatId);\r\n    if (!st.cart.length) {\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: \"–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞.\" });\r\n        return;\r\n    }\r\n\r\n    const total = st.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n    const rows = st.cart.map(r => ([\r\n        { text: \"‚àí\",                     callback_data: `cart:dec:${r.id}` },\r\n        { text: `${r.name} √ó${r.count}`, callback_data: \"noop\" },\r\n        { text: \"+\",                     callback_data: `cart:inc:${r.id}` },\r\n        { text: \"‚úñ\",                     callback_data: `cart:del:${r.id}` }\r\n    ]));\r\n    rows.push([{ text: \"–û—á–∏—Å—Ç–∏—Ç—å\", callback_data: \"cart:clear\" }, { text: \"üöö –û—Ñ–æ—Ä–º–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É\", callback_data: \"order:start\" }]);\r\n\r\n    await tg(\"sendMessage\", {\r\n        chat_id: chatId,\r\n        text: `üß∫ –ö–æ—Ä–∑–∏–Ω–∞:\\n${st.cart.map(r => `‚Ä¢ ${r.name} √ó ${r.count} = ${priceLabel(r.cost * r.count)}`).join(\"\\n\")}\\n\\n–ò—Ç–æ–≥–æ: ${priceLabel(total)}`,\r\n        ...ik(rows)\r\n    });\r\n}\r\n\r\n// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–∞—Ç–∞–ª–æ–≥–∞: –µ—Å–ª–∏ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤ –∏ –µ—Å—Ç—å –ø–æ–¥–ø–∞–ø–∫–∏ ‚Äî –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ\r\nasync function sendCategoryItems(chatId, catId, page = 0) {\r\n    const st = getState(chatId);\r\n    st.catId = catId ?? null;\r\n\r\n    const parentKey = catId ?? CATALOG.ROOT;\r\n    const foldersIdsBase = CATALOG.foldersByParent.get(parentKey) || [];\r\n    const foldersIds = applyOrder(foldersIdsBase, catId ?? null);\r\n    const itemsIdsAll = CATALOG.itemsByParent.get(parentKey) || [];\r\n\r\n    // –ê–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ\r\n    if (!itemsIdsAll.length && foldersIds.length) {\r\n        const first = foldersIds[0];\r\n        await sendCategoryItems(chatId, first, 0);\r\n        return;\r\n    }\r\n\r\n    const pageSize = DEFAULT_MENU_PAGE_SIZE;\r\n    const start = page * pageSize;\r\n    const itemsIds = itemsIdsAll.slice(start, start + pageSize);\r\n\r\n    const rows = [];\r\n\r\n    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∞–ø–∫–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å –∏ —Ç–æ–≤–∞—Ä—ã, –∏ –ø–∞–ø–∫–∏)\r\n    if (foldersIds.length && itemsIdsAll.length) {\r\n        for (const fid of foldersIds) {\r\n            const f = CATALOG.byId.get(fid);\r\n            rows.push([{ text: `üìÇ ${f?.name || \"–ö–∞—Ç–∞–ª–æ–≥\"}`, callback_data: `cat:${encId(fid)}:0` }]);\r\n        }\r\n    }\r\n\r\n    // –¢–æ–≤–∞—Ä—ã\r\n    for (const iid of itemsIds) {\r\n        const it = CATALOG.byId.get(iid);\r\n        const price = Number.isFinite(it.cost) ? priceLabel(it.cost) : \"‚Äî\";\r\n        rows.push([{ text: `${it.name} ‚Ä¢ ${price}`, callback_data: `add:${it.id}` }]);\r\n    }\r\n\r\n    // –ü–∞–≥–∏–Ω–∞—Ü–∏—è (—á–∏—Å–ª–æ–≤–∞—è, –º–∞–∫—Å–∏–º—É–º 5 –∫–Ω–æ–ø–æ–∫)\r\n    const totalPages = Math.ceil(itemsIdsAll.length / pageSize);\r\n    if (totalPages > 1) {\r\n        const navRow = [];\r\n        const currentPage = page;\r\n\r\n        const range = [];\r\n        for (let i = currentPage - 2; i <= currentPage + 2; i++) {\r\n            if (i >= 0 && i < totalPages) range.push(i);\r\n        }\r\n\r\n        for (const p of range) {\r\n            const isCurrent = p === currentPage;\r\n            const text = isCurrent ? `üëÅ ${p + 1}` : `${p + 1}`;\r\n            navRow.push({ text, callback_data: `ipage:${encId(catId ?? \"root\")}:${p}` });\r\n        }\r\n\r\n        rows.push(navRow);\r\n    }\r\n\r\n    // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å–æ—Å–µ–¥—è–º / –ù–∞–∑–∞–¥\r\n    if (catId != null) {\r\n        const srow = siblingNavRow(catId);\r\n        if (srow) rows.push(srow);\r\n    }\r\n\r\n    // –ö–æ—Ä–∑–∏–Ω–∞ –∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ\r\n    const cs = cartSummary(st);\r\n    rows.push([\r\n        { text: `üß∫ –ö–æ—Ä–∑–∏–Ω–∞ (${cs.count} | ${priceLabel(cs.total)})`, callback_data: \"cart:show\" },\r\n        { text: \"üöö –û—Ñ–æ—Ä–º–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É\", callback_data: \"order:start\" }\r\n    ]);\r\n\r\n    // –ó–∞–≥–æ–ª–æ–≤–æ–∫\r\n    const title = catId === null\r\n        ? `–ú–µ–Ω—é: ${st.currentPriceListName || \"\"}`\r\n        : `–ú–µ–Ω—é: ${st.currentPriceListName || \"\"} / ${CATALOG.byId.get(catId)?.name || \"\"}`;\r\n\r\n    // –ü–æ–¥–≤–∞–ª —Å –∫–æ—Ä–∑–∏–Ω–æ–π\r\n    const footer = cs.count\r\n        ? `\\n\\nüß∫ –°–µ–π—á–∞—Å –≤ –∫–æ—Ä–∑–∏–Ω–µ: ${cs.count} ‚Ä¢ –ò—Ç–æ–≥–æ: ${priceLabel(cs.total)}\\n${cs.preview.join(\"\\n\")}`\r\n        : `\\n\\nüß∫ –ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞`;\r\n\r\n    await tg(\"sendMessage\", {\r\n        chat_id: chatId,\r\n        text: title + footer,\r\n        ...ik(rows)\r\n    });\r\n}\r\n\r\n// ====== –û–§–û–†–ú–õ–ï–ù–ò–ï, –ê–î–†–ï–°–ê, –°–õ–û–¢–´, –û–ü–õ–ê–¢–ê ======\r\nasync function askAddress(chatId) {\r\n    const st = getState(chatId);\r\n    st.flow = \"address_wait\";\r\n\r\n    let rows = [];\r\n    try {\r\n        const prev = await dbGetAddresses(chatId, 6);\r\n        if (prev.length) {\r\n            st.addrPrev = prev;\r\n            for (let i = 0; i < prev.length; i++) rows.push([{ text: prev[i].addressFull, callback_data: `addrprev:${i}` }]);\r\n            rows.push([{ text: \"‚ûï –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å\", callback_data: \"addr:new\" }]);\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: \"–í—ã–±–µ—Ä–∏ –æ–¥–∏–Ω –∏–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤ –∏–ª–∏ –≤–≤–µ–¥–∏ –Ω–æ–≤—ã–π:\", ...ik(rows) });\r\n            return;\r\n        }\r\n    } catch {}\r\n\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: \"–í–≤–µ–¥–∏ –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –≥–æ—Ä–æ–¥, —É–ª–∏—Ü–∞, –¥–æ–º (–∫–≤/–ø–æ–¥—ä–µ–∑–¥/—ç—Ç–∞–∂ –º–æ–∂–Ω–æ –ø–æ—Ç–æ–º).\" });\r\n}\r\nasync function handleAddressInput(chatId, text) {\r\n    const st = getState(chatId);\r\n    const sug = await sabySuggestedAddress(text);\r\n    const list = Array.isArray(sug?.addresses) ? sug.addresses.slice(0, 10) : [];\r\n    if (!list.length) {\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: \"–ù–µ –Ω–∞—à–ª–∞ –ø–æ—Ö–æ–∂–∏—Ö –∞–¥—Ä–µ—Å–æ–≤. –í–≤–µ–¥–∏ —Ç–æ—á–Ω–µ–µ.\" });\r\n        return;\r\n    }\r\n    st.addrOptions = list;\r\n    const rows = list.map((a, i) => [{ text: a.addressFull, callback_data: `addrpick:${i}` }]);\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: \"–í—ã–±–µ—Ä–∏ –∞–¥—Ä–µ—Å:\", ...ik(rows) });\r\n}\r\nasync function afterAddressPicked(chatId) {\r\n    const st = getState(chatId);\r\n    const cost = await sabyDeliveryCost(POINT_ID, st.addressJSON);\r\n    st.deliveryCost = cost;\r\n    dbSaveAddress(chatId, st.addressFull, st.addressJSON).catch(() => {});\r\n\r\n    const c = Number(cost?.cost ?? 0);\r\n    const min = Number(cost?.minDeliverySum ?? 0);\r\n    const freeFrom = Number(cost?.costForFreeDelivery ?? 0);\r\n    const note =\r\n        `–ê–¥—Ä–µ—Å: ${st.addressFull}\\n` +\r\n        `–î–æ—Å—Ç–∞–≤–∫–∞: ${priceLabel(c)}${freeFrom ? `, –±–µ—Å–ø–ª–∞—Ç–Ω–æ –æ—Ç ${priceLabel(freeFrom)}` : \"\"}\\n` +\r\n        `${min ? `–ú–∏–Ω. —Å—É–º–º–∞ –∑–∞–∫–∞–∑–∞: ${priceLabel(min)}` : \"\"}`;\r\n\r\n    const cal = await sabyDeliveryCalendar(POINT_ID, 0, 7);\r\n    const dates = Array.isArray(cal?.dates) ? cal.dates : [];\r\n\r\n    const now = DateTime.now().setZone(BUSINESS_TZ);\r\n    const prepared = [];\r\n    for (const d of dates) {\r\n        const dateStr = d.Date ?? d.date;\r\n        if (!dateStr) continue;\r\n        const indices = normalizeCalendarIntervals(d.Intervals ?? d.intervals).filter(i => i >= SLOT_OPEN_IDX && i <= SLOT_CLOSE_IDX);\r\n        if (!indices.length) continue;\r\n\r\n        const dateISO = DateTime.fromISO(`${dateStr}T00:00:00`, { zone: BUSINESS_TZ });\r\n        const isToday = dateISO.hasSame(now, 'day');\r\n        let cutoffIdx = SLOT_OPEN_IDX;\r\n        if (isToday) {\r\n            const minutesSinceMidnight = now.hour * 60 + now.minute;\r\n            const k = Math.ceil(Math.max(0, minutesSinceMidnight - 30) / 30);\r\n            cutoffIdx = Math.max(SLOT_OPEN_IDX, k);\r\n        }\r\n        prepared.push({\r\n            dateStr,\r\n            human: DateTime.fromISO(dateStr, { zone: BUSINESS_TZ }).toFormat('dd.LL (ccc)'),\r\n            indices, cutoffIdx, isToday\r\n        });\r\n        if (prepared.length === 4) break;\r\n    }\r\n\r\n    if (!prepared.length) {\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: `–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤.\\n${note}` });\r\n        return;\r\n    }\r\n\r\n    const rows = [];\r\n    rows.push(prepared.map(col => ({ text: col.human, callback_data: \"noop\" })));\r\n\r\n    for (let idx = SLOT_OPEN_IDX; idx <= SLOT_CLOSE_IDX; idx++) {\r\n        const row = [];\r\n        for (const col of prepared) {\r\n            if ((col.isToday && idx < col.cutoffIdx) || !col.indices.includes(idx)) {\r\n                row.push({ text: \"‚Äî\", callback_data: \"noop\" });\r\n            } else {\r\n                row.push({ text: slotLabel(idx), callback_data: `slot:${col.dateStr}:${idx}` });\r\n            }\r\n        }\r\n        rows.push(row);\r\n    }\r\n    rows.push([{ text: \"–ò–∑–º–µ–Ω–∏—Ç—å –∞–¥—Ä–µ—Å\", callback_data: \"order:address\" }]);\r\n\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: `–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è.\\n${note}`, ...ik(rows) });\r\n}\r\nasync function askPayment(chatId) {\r\n    const st = getState(chatId);\r\n    st.flow = \"payment_wait\";\r\n    const rows = [\r\n        // [{ text: \"üí≥ –û–Ω–ª–∞–π–Ω –æ–ø–ª–∞—Ç–∞\", callback_data: \"pay:online\" }],\r\n        [{ text: \"üíµ –ù–∞–ª–∏—á–Ω—ã–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏\", callback_data: \"pay:cash\" }],\r\n        [{ text: \"ü§ù –ü–µ—Ä–µ–≤–æ–¥ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏\", callback_data: \"pay:transfer\" }]\r\n    ];\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: \"–í—ã–±–µ—Ä–∏ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:\", ...ik(rows) });\r\n}\r\nasync function waitForPaymentAndFinalize(chatId, externalId, total, {timeoutMs = 15 * 60 * 1000, pollMs = 4000} = {}) {\r\n    const started = Date.now();\r\n    let notifiedTick = 0;\r\n    while (Date.now() - started < timeoutMs) {\r\n        await new Promise(r => setTimeout(r, pollMs));\r\n        try {\r\n            const s = await sabyOrderState(externalId);\r\n            const paid = Array.isArray(s?.payments) && s.payments.some(p => p?.isClosed === true);\r\n            if (paid) {\r\n                try { await sabyRegisterPayment(externalId, { bankSum: Number(total) || 0, retailPlace: SHOP_URL, paymentType: \"full\" }); } catch (e) {}\r\n                await tg(\"sendMessage\", { chat_id: chatId, text: \"‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞. –ó–∞–∫–∞–∑ –ø–µ—Ä–µ–¥–∞–Ω –Ω–∞ —Ç–æ—á–∫—É –∏ —Ñ–∏—Å–∫–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.\" });\r\n                return true;\r\n            }\r\n            notifiedTick++;\r\n            if (notifiedTick % Math.ceil(60_000 / pollMs) === 0) {\r\n                await tg(\"sendMessage\", { chat_id: chatId, text: \"–ñ–¥—É –æ–ø–ª–∞—Ç—É, –∫–∞–∫ –∫–æ—à–∫–∞ ‚Äî —Ä—ã–±—É. –°—Å—ã–ª–∫–∞ –≤—ã—à–µ –≤—Å—ë –µ—â—ë –¥–µ–π—Å—Ç–≤—É–µ—Ç.\" }).catch(() => {});\r\n            }\r\n        } catch {}\r\n    }\r\n    try { await sabyCancelOrder(externalId); } catch {}\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: \"‚è≥ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ–ø–ª–∞—Ç—ã –∏—Å—Ç–µ–∫–ª–æ. –ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω—ë–Ω. –ï—Å–ª–∏ –¥–µ–Ω—å–≥–∏ –≤—Å—ë-—Ç–∞–∫–∏ —Å–ø–∏—Å–∞–ª–∏—Å—å, –æ–Ω–∏ –æ—Ç–∫–∞—Ç—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–ª–∏ —Å–≤—è–∂–µ–º—Å—è –≤—Ä—É—á–Ω—É—é.\" });\r\n    return false;\r\n}\r\nasync function askPhone(chatId) {\r\n    const st = getState(chatId);\r\n    st.flow = \"phone_wait\";\r\n    const replyMarkup = {\r\n        keyboard: [[{ text: \"üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω\", request_contact: true }]],\r\n        resize_keyboard: true,\r\n        one_time_keyboard: true\r\n    };\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: \"–ù—É–∂–µ–Ω —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —Å–≤—è–∑–∏. –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.\", reply_markup: JSON.stringify(replyMarkup) });\r\n}\r\nasync function createOrder(chatId) {\r\n    const st = getState(chatId);\r\n    const customerName = st.customer?.name || \"–ì–æ—Å—Ç—å\";\r\n    const customerPhone = normalizePhone(st.customer?.phone || \"\") || null;\r\n\r\n    if (!st.cart?.length) { await tg(\"sendMessage\", { chat_id: chatId, text: \"–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞. –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ –º–µ–Ω—é.\" }); return; }\r\n    if (!st.addressJSON || !st.slot) { await tg(\"sendMessage\", { chat_id: chatId, text: \"–ù—É–∂–Ω—ã –∞–¥—Ä–µ—Å –∏ —Å–ª–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏.\" }); return; }\r\n    if (!customerPhone) { await tg(\"sendMessage\", { chat_id: chatId, text: \"–ù–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ü–æ–≤—Ç–æ—Ä–∏ –≤–≤–æ–¥.\" }); return askPhone(chatId); }\r\n\r\n    const datetimeISO = toLocalPrestoDate(st.slot.date, st.slot.halfHourIndex);\r\n    const priceListId = Number.parseInt(String(FIXED_PRICE_LIST_ID), 10);\r\n    if (!Number.isFinite(priceListId)) { await tg(\"sendMessage\", { chat_id: chatId, text: \"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø—Ä–∞–π—Å-–ª–∏—Å—Ç. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.\" }); return; }\r\n\r\n    const nomenclatures = st.cart.map(r => {\r\n        const idNum = Number.parseInt(String(r.id), 10);\r\n        const base = { count: Number.isFinite(Number(r.count)) ? Number(r.count) : 1, priceListId };\r\n        if (Number.isFinite(idNum)) base.id = idNum; else base.nomNumber = String(r.id);\r\n        const costNum = Number(r.cost); if (Number.isFinite(costNum)) base.cost = costNum;\r\n        base.name = r.name; return base;\r\n    });\r\n    const addressJSONString = typeof st.addressJSON === \"string\" ? st.addressJSON : JSON.stringify(st.addressJSON);\r\n\r\n    const pm = (st.paymentMethod === \"cash\" || st.paymentMethod === \"transfer\" || st.paymentMethod === \"online\") ? st.paymentMethod : \"online\";\r\n    const delivery = {\r\n        isPickup: false,\r\n        addressJSON: addressJSONString,\r\n        addressFull: st.addressFull || undefined,\r\n        shopURL: SHOP_URL, successURL: SUCCESS_URL, errorURL: ERROR_URL,\r\n        paymentType: pm === \"online\" ? \"online\" : \"cash\"\r\n    };\r\n    const payNote = pm === \"online\" ? \"–û–ø–ª–∞—Ç–∞: –æ–Ω–ª–∞–π–Ω\" : (pm === \"cash\" ? \"–û–ø–ª–∞—Ç–∞: –Ω–∞–ª–∏—á–Ω—ã–µ\" : \"–û–ø–ª–∞—Ç–∞: –ø–µ—Ä–µ–≤–æ–¥\");\r\n\r\n    const payload = {\r\n        product: \"delivery\",\r\n        pointId: Number(POINT_ID),\r\n        comment: `–ó–∞–∫–∞–∑ –∏–∑ Telegram –æ—Ç ${customerName}. ${payNote} ‚Ä¢ –û–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã.`,\r\n        customer: { externalId: generateStableUuid(String(chatId)), name: customerName, phone: customerPhone },\r\n        datetime: datetimeISO,\r\n        nomenclatures, delivery\r\n    };\r\n\r\n    const created = await sabyCreateOrder(payload);\r\n    const orderExternalId =\r\n        created?.externalId ?? created?.orderExternalId ?? created?.result?.externalId ??\r\n        created?.result?.orderExternalId ?? created?.id ?? created?.orderId ?? null;\r\n    if (!orderExternalId) { await tg(\"sendMessage\", { chat_id: chatId, text: \"Saby –Ω–µ –≤–µ—Ä–Ω—É–ª –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–∫–∞–∑–∞. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.\" }); return; }\r\n\r\n    let stateObj = null; try { stateObj = await sabyOrderState(orderExternalId); } catch {}\r\n    if (!stateObj || !Number.isFinite(Number(stateObj.state))) {\r\n        const total = st.cart.reduce((s, r) => s + (Number(r.cost) || 0) * (Number(r.count) || 1), 0);\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: [\"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–∫–∞–∑–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ Saby.\",\"–°–ª–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏ –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω.\",`–ò—Ç–æ–≥–æ –ø–æ –∫–æ—Ä–∑–∏–Ω–µ: ${priceLabel(total)}`].join(\"\\n\") });\r\n        return;\r\n    }\r\n\r\n    st.lastExternalId = orderExternalId;\r\n    const total = st.cart.reduce((s, r) => s + (Number(r.cost) || 0) * (Number(r.count) || 1), 0);\r\n\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: `–ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω. –ù–æ–º–µ—Ä: ${orderExternalId}` });\r\n\r\n    if (pm === \"online\") {\r\n        try {\r\n            const link = await sabyPaymentLink(orderExternalId, { shopURL: SHOP_URL, successURL: SUCCESS_URL, errorURL: ERROR_URL });\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: [\"–û–ø–ª–∞—Ç–∏—Ç—å –∑–∞–∫–∞–∑ –¥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è:\", `–ò—Ç–æ–≥–æ –∫ –æ–ø–ª–∞—Ç–µ: ${priceLabel(total)}`].join(\"\\n\"), ...ik([[{ text: \"üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ\", url: link.link }]]) });\r\n            setTimeout(() => {}, 0);\r\n            waitForPaymentAndFinalize(chatId, orderExternalId, total).catch(() => {});\r\n        } catch {\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: [\"–û–Ω–ª–∞–π–Ω-–æ–ø–ª–∞—Ç–∞ —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.\",\"–ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω, –æ–ø–ª–∞—Ç—É –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –≤–Ω–µ—Å—Ç–∏ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏.\",`–ò—Ç–æ–≥–æ –ø–æ –∑–∞–∫–∞–∑—É: ${priceLabel(total)}`].join(\"\\n\") });\r\n        }\r\n        return;\r\n    }\r\n    if (pm === \"cash\") {\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: [\"–û–ø–ª–∞—Ç–∞ –Ω–∞–ª–∏—á–Ω—ã–º–∏ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏.\", `–ò—Ç–æ–≥–æ –ø–æ –∑–∞–∫–∞–∑—É: ${priceLabel(total)}`].join(\"\\n\") });\r\n    } else {\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: [\"–û–ø–ª–∞—Ç–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–º. –†–µ–∫–≤–∏–∑–∏—Ç—ã —É—Ç–æ—á–Ω—è—Ç –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏.\", `–ò—Ç–æ–≥–æ –ø–æ –∑–∞–∫–∞–∑—É: ${priceLabel(total)}`].join(\"\\n\") });\r\n    }\r\n}\r\n\r\n// ====== –†–ï–ñ–ò–ú –°–û–†–¢–ò–†–û–í–ö–ò (–¥–ª—è ADMIN_ID) ======\r\nfunction renderSortKeyboard(parentId) {\r\n    const base = (CATALOG.foldersByParent.get(parentId ?? CATALOG.ROOT) || []).slice();\r\n    const ids = getOrderedAll(base, parentId ?? null); // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ, –≤–∫–ª—é—á–∞—è —Å–∫—Ä—ã—Ç—ã–µ\r\n    const cfg = CATEGORY_ORDER.get(parentId ?? null) || { hidden: new Set(), order: [] };\r\n\r\n    const rows = ids.map(id => {\r\n        const name = CATALOG.byId.get(id)?.name || \"–ö–∞—Ç–∞–ª–æ–≥\";\r\n        const isHidden = cfg.hidden.has(String(id));\r\n        const eye = isHidden ? \"üö´\" : \"üëÅ\";\r\n        return [\r\n            { text: \"‚Üë\", callback_data: `sort:up:${encId(parentId ?? \"root\")}:${encId(id)}` },\r\n            { text: `${eye} ${name}`, callback_data: `sort:toggle:${encId(parentId ?? \"root\")}:${encId(id)}` },\r\n            { text: \"‚Üì\", callback_data: `sort:down:${encId(parentId ?? \"root\")}:${encId(id)}` }\r\n        ];\r\n    });\r\n\r\n    // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –¥–µ—Ä–µ–≤—É\r\n    const navRow = [];\r\n    if (parentId != null) {\r\n        navRow.push({ text: \"‚¨ÜÔ∏è –í–≤–µ—Ä—Ö\", callback_data: `sort:open:${encId(CATALOG.parentById.get(parentId) ?? \"root\")}` });\r\n    }\r\n    for (const fid of base.slice(0, 3)) {\r\n        navRow.push({ text: `üìÇ ${CATALOG.byId.get(fid)?.name || \"–ö–∞—Ç–∞–ª–æ–≥\"}`, callback_data: `sort:open:${encId(fid)}` });\r\n    }\r\n    if (navRow.length) rows.push(navRow);\r\n\r\n    rows.push([{ text: \"‚úÖ –ì–æ—Ç–æ–≤–æ\", callback_data: \"sort:exit\" }]);\r\n    return { rows, ids };\r\n}\r\nasync function showSortMenu(chatId, parentId = null) {\r\n    const { rows } = renderSortKeyboard(parentId);\r\n    const title = parentId == null ? \"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –∫–æ—Ä–µ–Ω—å\" : `–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: ${CATALOG.byId.get(parentId)?.name || \"–ö–∞—Ç–∞–ª–æ–≥\"}`;\r\n    await tg(\"sendMessage\", { chat_id: chatId, text: title + \"\\n–ü–µ—Ä–≤—ã–π —Å–≤–µ—Ä—Ö—É ‚Äî –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ.\", ...ik(rows) });\r\n}\r\nasync function moveInOrder(parentId, itemId, dir) {\r\n    const base = (CATALOG.foldersByParent.get(parentId ?? CATALOG.ROOT) || []).slice();\r\n    let ids = getOrderedAll(base, parentId ?? null); // –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞ —Å–∫—Ä—ã—Ç—ã—Ö\r\n    const i = ids.findIndex(x => String(x) === String(itemId));\r\n    if (i < 0) return;\r\n    const j = dir < 0 ? Math.max(0, i - 1) : Math.min(ids.length - 1, i + 1);\r\n    if (i === j) return;\r\n    const x = ids[i]; ids.splice(i, 1); ids.splice(j, 0, x);\r\n    await saveOrder(parentId ?? null, ids);\r\n}\r\n\r\n// ====== –•–ï–ù–î–õ–ï–†–´ ======\r\nasync function handleMessage(m) {\r\n    const chatId = m.chat.id;\r\n    const text = m.text?.trim() || \"\";\r\n    const st = getState(chatId);\r\n\r\n    if (text === \"/start\") {\r\n        await ensureCartLoaded(chatId);\r\n\r\n        const cs = cartSummary(st, 6);\r\n        const hello = [\r\n            \"–ü—Ä–∏–≤–µ—Ç. –≠—Ç–æ –±–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏.\",\r\n            cs.count ? `üß∫ –í –∫–æ—Ä–∑–∏–Ω–µ: ${cs.count} ‚Ä¢ –ò—Ç–æ–≥–æ: ${priceLabel(cs.total)}` : \"üß∫ –ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞\",\r\n            ...(cs.preview.length ? [\"\", ...cs.preview] : [])\r\n        ].join(\"\\n\");\r\n\r\n        const main = st.mainCategories?.length ? st.mainCategories : buildMainCategories();\r\n        st.mainCategories = main;\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: hello, ...buildMainReplyKeyboard(main) });\r\n\r\n        if (m.from?.id === ADMIN_ID) {\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: \"–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –∫–æ–º–∞–Ω–¥–∞ /sort\" });\r\n        }\r\n        return;\r\n    }\r\n\r\n    if (text === \"/menu\" || text === \"üìã –ú–µ–Ω—é\") {\r\n        const main = st.mainCategories?.length ? st.mainCategories : buildMainCategories();\r\n        st.mainCategories = main;\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: `–ú–µ–Ω—é: ${st.currentPriceListName}`, ...buildMainReplyKeyboard(main) });\r\n        return;\r\n    }\r\n\r\n    if (text === \"/cart\" || text === \"üß∫ –ö–æ—Ä–∑–∏–Ω–∞\") { await showCart(chatId); return; }\r\n    if (text === \"/order\" || text === \"üöö –î–æ—Å—Ç–∞–≤–∫–∞\") { await askAddress(chatId); return; }\r\n    if (text === \"/status\") {\r\n        if (!st.lastExternalId) { await tg(\"sendMessage\", { chat_id: chatId, text: \"–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–∫–∞–∑–æ–≤.\" }); return; }\r\n        const s = await sabyOrderState(st.lastExternalId);\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: `–°—Ç–∞—Ç—É—Å: ${JSON.stringify(s)}` });\r\n        return;\r\n    }\r\n\r\n    // === –∞–¥–º–∏–Ω: –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ ===\r\n    if (text === \"/diag\" && m.from?.id === ADMIN_ID) {\r\n        try {\r\n            const msg = dumpTreePreview(CATALOG, 20, 3);\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: \"–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞:\\n\" + msg });\r\n        } catch(e) {\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: \"–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: \" + (e?.message || e) });\r\n        }\r\n        return;\r\n    }\r\n\r\n    if (text === \"/sort\" && m.from?.id === ADMIN_ID) {\r\n        st.sortMode = { parentId: null };\r\n        await showSortMenu(chatId, null);\r\n        return;\r\n    }\r\n\r\n    // –ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤ reply keyboard\r\n    const hit = (st.mainCategories || []).find(c => c.name === text);\r\n    if (hit) { await sendCategoryItems(chatId, hit.id, 0); return; }\r\n\r\n    if (st.flow === \"address_wait\" && text) return handleAddressInput(chatId, text);\r\n\r\n    if (st.flow === \"phone_wait\" && m.contact?.phone_number) {\r\n        const norm = normalizePhone(m.contact.phone_number);\r\n        st.customer = { ...(st.customer || {}), name: m.from?.first_name || \"–ì–æ—Å—Ç—å\", phone: norm };\r\n        st.flow = null;\r\n        dbSavePhone(chatId, norm, true).catch(() => {});\r\n        await tg(\"sendMessage\", { chat_id: chatId, text: `–°–ø–∞—Å–∏–±–æ, –Ω–æ–º–µ—Ä –ø–æ–ª—É—á–µ–Ω: ${norm}`, reply_markup: JSON.stringify({ remove_keyboard: true }) });\r\n        return createOrder(chatId);\r\n    }\r\n    if (st.flow === \"phone_wait\" && text) {\r\n        const norm = normalizePhone(text);\r\n        if (!norm) return tg(\"sendMessage\", { chat_id: chatId, text: \"–ù–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ –Ω–æ–º–µ—Ä. –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω¬ª –∏–ª–∏ –≤–≤–µ–¥–∏ —Ñ–æ—Ä–º–∞—Ç +79XXXXXXXXX.\" });\r\n        st.customer = { ...(st.customer || {}), name: m.from?.first_name || \"–ì–æ—Å—Ç—å\", phone: norm };\r\n        st.flow = null;\r\n        dbSavePhone(chatId, norm, false).catch(() => {});\r\n        return createOrder(chatId);\r\n    }\r\n}\r\n\r\nasync function handleCallback(cb) {\r\n    const chatId = cb.message.chat.id;\r\n    const data = cb.data || \"\";\r\n    const st = getState(chatId);\r\n\r\n    const isQuickToast =\r\n        data.startsWith(\"add:\") ||\r\n        data === \"cart:show\" ||\r\n        data === \"cart:clear\" ||\r\n        data.startsWith(\"cart:dec:\") ||\r\n        data.startsWith(\"cart:inc:\") ||\r\n        data.startsWith(\"cart:del:\");\r\n\r\n    if (!isQuickToast) await answerCbSafe(cb);\r\n\r\n    if (data === \"noop\") return;\r\n\r\n    // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Ç–æ–≤–∞—Ä–∞–º —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º–∏\r\n    if (data.startsWith(\"ipage:\")) {\r\n        const [, enc, rawPage] = data.split(\":\");\r\n        const decoded = decId(enc);\r\n        const catId = decoded === \"root\" ? null : decoded;\r\n        const page = Number(rawPage || 0);\r\n        await sendCategoryItems(chatId, catId, page);\r\n        return;\r\n    }\r\n\r\n    // –í—Ö–æ–¥ –≤ –∫–∞—Ç–∞–ª–æ–≥\r\n    if (data.startsWith(\"cat:\")) {\r\n        const [, enc, rawPage] = data.split(\":\");\r\n        const decoded = decId(enc);\r\n        const catId = decoded === \"root\" ? null : decoded;\r\n        const page = Number(rawPage || 0);\r\n        await sendCategoryItems(chatId, catId, page);\r\n        return;\r\n    }\r\n\r\n    // ¬´–ù–∞–∑–∞–¥¬ª —Å—Ç—Ä–æ–≥–æ –Ω–∞ –æ–¥–∏–Ω —É—Ä–æ–≤–µ–Ω—å –≤–≤–µ—Ä—Ö\r\n    if (data.startsWith(\"back:\")) {\r\n        const [, enc] = data.split(\":\");\r\n        const decoded = decId(enc);\r\n        const catId = decoded === \"root\" ? null : decoded;\r\n        await sendCategoryItems(chatId, catId, 0);\r\n        return;\r\n    }\r\n\r\n    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞\r\n    if (data.startsWith(\"add:\")) {\r\n        const id = data.split(\":\")[1];\r\n        const res = await addToCart(chatId, id);\r\n        const toast = res.added ? `+1 ‚Ä¢ ${res.name} | ${priceLabel(res.total)}` : \"–ù–µ —É–¥–∞–ª–æ—Å—å\";\r\n        await answerCbSafe(cb, toast);\r\n        return;\r\n    }\r\n\r\n    // –ö–æ—Ä–∑–∏–Ω–∞ –ø–æ–∫–∞–∑–∞—Ç—å/–æ—á–∏—Å—Ç–∏—Ç—å/–ø—Ä–∞–≤–∫–∏\r\n    if (data === \"cart:show\") { await showCart(chatId); await answerCbSafe(cb); return; }\r\n    if (data === \"cart:clear\") {\r\n        const st2 = await ensureCartLoaded(chatId);\r\n        st2.cart = [];\r\n        await dbSaveCart(chatId, st2.cart).catch(() => {});\r\n        await showCart(chatId);\r\n        await answerCbSafe(cb, \"–û—á–∏—â–µ–Ω–æ\");\r\n        return;\r\n    }\r\n    if (data.startsWith(\"cart:dec:\")) {\r\n        const id = data.split(\":\")[2];\r\n        await changeCartQty(chatId, id, -1);\r\n        await showCart(chatId);\r\n        await answerCbSafe(cb, \"‚àí1\");\r\n        return;\r\n    }\r\n    if (data.startsWith(\"cart:inc:\")) {\r\n        const id = data.split(\":\")[2];\r\n        await changeCartQty(chatId, id, +1);\r\n        await showCart(chatId);\r\n        await answerCbSafe(cb, \"+1\");\r\n        return;\r\n    }\r\n    if (data.startsWith(\"cart:del:\")) {\r\n        const id = data.split(\":\")[2];\r\n        await deleteCartItem(chatId, id);\r\n        await showCart(chatId);\r\n        await answerCbSafe(cb, \"–£–¥–∞–ª–µ–Ω–æ\");\r\n        return;\r\n    }\r\n\r\n    // –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ\r\n    if (data === \"order:start\" || data === \"order:address\") { await askAddress(chatId); return; }\r\n    if (data.startsWith(\"addrprev:\")) {\r\n        const idx = Number(data.split(\":\")[1] || 0);\r\n        const opt = st.addrPrev?.[idx];\r\n        if (!opt) { await answerCbSafe(cb, \"–ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω\"); return; }\r\n        st.addressFull = opt.addressFull; st.addressJSON = opt.addressJSON; st.addrPrev = null;\r\n        await afterAddressPicked(chatId); return;\r\n    }\r\n    if (data === \"addr:new\") { st.addrPrev = null; await tg(\"sendMessage\", { chat_id: chatId, text: \"–û–∫, –≤–≤–µ–¥–∏ –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å:\" }); return; }\r\n    if (data.startsWith(\"addrpick:\")) {\r\n        const idx = Number(data.split(\":\")[1] || 0);\r\n        const opt = st.addrOptions?.[idx];\r\n        if (!opt) { await answerCbSafe(cb, \"–ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω\"); return; }\r\n        st.addressFull = opt.addressFull; st.addressJSON = opt.addressJSON; st.addrOptions = null;\r\n        dbSaveAddress(chatId, st.addressFull, st.addressJSON).catch(() => {});\r\n        await afterAddressPicked(chatId); return;\r\n    }\r\n    if (data.startsWith(\"slot:\")) {\r\n        const [, date, idx] = data.split(\":\");\r\n        st.slot = { date, halfHourIndex: Number(idx) };\r\n        await askPayment(chatId); return;\r\n    }\r\n    if (data.startsWith(\"pay:\")) {\r\n        const method = data.split(\":\")[1];\r\n        if (![\"online\", \"cash\", \"transfer\"].includes(method)) { await answerCbSafe(cb, \"–°–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è\"); return; }\r\n        st.paymentMethod = method; st.flow = null; await askPhone(chatId); return;\r\n    }\r\n\r\n    // === –°–û–†–¢–ò–†–û–í–ö–ê (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞) ===\r\n    if (cb.from?.id === ADMIN_ID && data.startsWith(\"sort:\")) {\r\n        const parts = data.split(\":\"); // sort:<cmd>:<parentEnc or targetEnc>:<idEnc?>\r\n        const cmd = parts[1];\r\n\r\n        if (cmd === \"up\" || cmd === \"down\") {\r\n            const parentDec = decId(parts[2]); const parentId = parentDec === \"root\" ? null : parentDec;\r\n            const id = decId(parts[3]);\r\n            await moveInOrder(parentId, id, cmd === \"up\" ? -1 : +1);\r\n            await answerCbSafe(cb, cmd === \"up\" ? \"‚Üë\" : \"‚Üì\");\r\n            await showSortMenu(chatId, parentId);\r\n            return;\r\n        }\r\n        if (cmd === \"open\") {\r\n            const targetDec = decId(parts[2]); // —Ç—É—Ç parts[2] ‚Äî —Ü–µ–ª–µ–≤–æ–π id\r\n            const target = targetDec === \"root\" ? null : targetDec;\r\n            await showSortMenu(chatId, target);\r\n            return;\r\n        }\r\n        if (cmd === \"exit\") {\r\n            const st2 = getState(chatId);\r\n            delete st2.sortMode;\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: \"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.\" });\r\n            const main = buildMainCategories();\r\n            st2.mainCategories = main;\r\n            await tg(\"sendMessage\", { chat_id: chatId, text: `–ú–µ–Ω—é: ${st2.currentPriceListName}`, ...buildMainReplyKeyboard(main) });\r\n            return;\r\n        }\r\n        if (cmd === \"toggle\") {\r\n            // –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–∫—Ä—ã—Ç–æ—Å—Ç—å –≤ –ë–î, –ø–æ—Ä—è–¥–æ–∫ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º\r\n            const parentDec = decId(parts[2]); const parentId = parentDec === \"root\" ? null : parentDec;\r\n            const id = decId(parts[3]);\r\n            const pid = parentId == null ? null : String(parentId);\r\n            const cfg = CATEGORY_ORDER.get(pid) || { order: [], hidden: new Set() };\r\n            const hidden = new Set(cfg.hidden);\r\n            if (hidden.has(String(id))) hidden.delete(String(id));\r\n            else hidden.add(String(id));\r\n            await dbSaveMenuOrder(pid, cfg.order.map(String), [...hidden]);\r\n            CATEGORY_ORDER.set(pid, { order: cfg.order.map(String), hidden });\r\n            await answerCbSafe(cb, \"üëÅ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ\");\r\n            await showSortMenu(chatId, parentId);\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n// ====== –°–¢–ê–†–¢ ======\r\nfunction pickPointId(pointsResp) {\r\n    let list = Array.isArray(pointsResp?.salesPoints) ? pointsResp.salesPoints :\r\n        Array.isArray(pointsResp?.records) ? pointsResp.records :\r\n            Array.isArray(pointsResp) ? pointsResp : [];\r\n    if (!list.length) return null;\r\n    return list[0]?.id ?? null;\r\n}\r\n\r\nasync function startup() {\r\n    await dbInit();\r\n\r\n    // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π/—Å–∫—Ä—ã—Ç—ã–µ\r\n    const orders = await dbLoadAllMenuOrders().catch(() => []);\r\n    loadOrdersToMap(orders);\r\n\r\n    await sabyAuth();\r\n\r\n    const pointsResp = await sabyGetPoints();\r\n    POINT_ID = pickPointId(pointsResp);\r\n    if (!POINT_ID) throw new Error(\"–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∏ –æ–¥–Ω–∞ —Ç–æ—á–∫–∞ –ø—Ä–æ–¥–∞–∂.\");\r\n\r\n    const priceListsResp = await sabyGetPriceLists(POINT_ID);\r\n    PRICE_LISTS = (Array.isArray(priceListsResp?.records) ? priceListsResp.records :\r\n        Array.isArray(priceListsResp?.result) ? priceListsResp.result :\r\n            Array.isArray(priceListsResp) ? priceListsResp : []).map(x => ({\r\n        id: x.id ?? x.priceListId ?? x.key,\r\n        name: x.name ?? x.title ?? `–ü—Ä–∞–π—Å #${x.id ?? x.priceListId ?? x.key}`\r\n    })).filter(p => p.id);\r\n\r\n    catDbg(`[menu] price-lists found: ${PRICE_LISTS.length}`);\r\n    vdbg(`[menu] price-lists: ${PRICE_LISTS.map(p => `${p.id}:${p.name}`).join(\" | \")}`);\r\n\r\n    // –ù–æ–º–µ–Ω–∫–ª–∞—Ç—É—Ä–∞ –∏–∑ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∞–π—Å–∞\r\n    const nomenclatureResp = await sabyGetNomenclature(POINT_ID, FIXED_PRICE_LIST_ID, 0, 2000);\r\n    const records = Array.isArray(nomenclatureResp?.nomenclatures) ? nomenclatureResp.nomenclatures :\r\n        Array.isArray(nomenclatureResp?.records) ? nomenclatureResp.records :\r\n            Array.isArray(nomenclatureResp?.result) ? nomenclatureResp.result :\r\n                Array.isArray(nomenclatureResp) ? nomenclatureResp : [];\r\n    catDbg(\"[menu] nomenclature typeof:\", typeof nomenclatureResp);\r\n    catDbg(\"[menu] nomenclature keys:\", Object.keys(nomenclatureResp || {}));\r\n    catDbg(\"[menu] records count:\", records.length);\r\n\r\n    CATALOG = buildCatalogIndexes(records);\r\n    catDbg(`[menu] catalog refreshed, folders: ${(CATALOG.foldersByParent.get(CATALOG.ROOT)||[]).length}, items: ${(CATALOG.itemsByParent.get(CATALOG.ROOT)||[]).length}`);\r\n\r\n    await tg(\"setMyCommands\", {\r\n        commands: [\r\n            { command: \"start\", description: \"–ó–∞–ø—É—Å–∫\" },\r\n            { command: \"menu\", description: \"–ú–µ–Ω—é\" },\r\n            { command: \"cart\", description: \"–ö–æ—Ä–∑–∏–Ω–∞\" },\r\n            { command: \"order\", description: \"–û—Ñ–æ—Ä–º–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É\" },\r\n            { command: \"status\", description: \"–°—Ç–∞—Ç—É—Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–∫–∞–∑–∞\" },\r\n            { command: \"sort\", description: \"–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ (–∞–¥–º–∏–Ω)\" },\r\n            { command: \"diag\", description: \"–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ (–∞–¥–º–∏–Ω)\" }\r\n        ]\r\n    });\r\n\r\n    dbg(`–ì–æ—Ç–æ–≤–æ. –¢–æ—á–∫–∞ ${POINT_ID}, –ø—Ä–∞–π—Å 64 \"${FIXED_PRICE_LIST_NAME}\". –ù–∞–≤–∏–≥–∞—Ü–∏—è: –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ/—Å—Ç—Ä–µ–ª–∫–∏/—É–º–Ω—ã–π –ù–∞–∑–∞–¥. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è ${ADMIN_ID}.`);\r\n}\r\n\r\n// ====== –ü–û–õ–õ–ò–ù–ì ======\r\n(async () => {\r\n    try {\r\n        await startup();\r\n        for (;;) {\r\n            const res = await fetch(`${TG_API}/getUpdates`, {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ timeout: 25, offset: UPDATE_OFFSET + 1 })\r\n            }).then(r => r.json()).catch(() => null);\r\n\r\n            if (!res || !res.ok) continue;\r\n\r\n            for (const up of res.result) {\r\n                UPDATE_OFFSET = up.update_id;\r\n                try {\r\n                    if (up.message) await handleMessage(up.message);\r\n                    if (up.callback_query) await handleCallback(up.callback_query);\r\n                } catch (e) {\r\n                    console.error(\"handler error\", e);\r\n                }\r\n            }\r\n        }\r\n    } catch (e) {\r\n        console.error(\"fatal:\", e);\r\n        process.exit(1);\r\n    }\r\n})();\r\n"
}