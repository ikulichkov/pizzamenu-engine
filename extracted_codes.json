{
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\index.js": "console.log('Happy developing ‚ú®')\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\engine.js": "// src/engine.js\r\n// –Ø–¥—Ä–æ –¥–≤–∏–∂–∫–∞. –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ callback-–¥–∞–Ω–Ω—ã—Ö: —Ç–æ–ª—å–∫–æ \"m:*\", –∫–∞–∫ –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ 1 (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å).\r\n// –ö–æ–º–∞–Ω–¥—ã: –∏–∑ 4 (+ /sort –¥–ª—è –∞–¥–º–∏–Ω–∞, –ø–∞—Ä–∏—Ç–µ—Ç —Å A –∏–∑ 2). /start —Å–æ—Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å —á—É–∂–∏–º, —Å–º. ctx.state.handled.\r\n// TZ: Intl.* –±–µ–∑ luxon.\r\n\r\nimport { createSabyClient } from './saby.js';\r\nimport { nowTZMinutesSinceMidnight, slotLabel } from './util-date.js';\r\nimport { priceLabel, encId, decId } from './shared.js';\r\n\r\nconst MENU_PREFIX = 'm:'; // –≤—Å—ë, —á—Ç–æ –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å m:, ‚Äî –Ω–µ –Ω–∞—à–µ –∏ –∏–≥–Ω–æ—Ä–∏–º. (–≤–∞—Ä–∏–∞–Ω—Ç 1)\r\n\r\nconst DEFAULTS = {\r\n    business: { timeZone: 'Asia/Vladivostok', slotOpenIdx: 20, slotCloseIdx: 42, adminId: 0 },\r\n    saby: { fixedPriceListId: 64, fixedPriceListName: '–ë–∞—Ä –æ—Å–Ω–æ–≤–Ω–æ–π' },\r\n    shop: { shopURL: 'https://pizza25.ru', successURL: 'https://pizza25.ru/pay/success', errorURL: 'https://pizza25.ru/pay/error' },\r\n    ui: { pageSize: 12 }\r\n};\r\n\r\n/** @typedef {{ready:()=>Promise<boolean>, getAddresses:(userId:number,limit?:number)=>Promise<any[]>, saveAddress:(userId:number,full:string,json:any)=>Promise<void>, savePhone:(userId:number,phone:string,isPrimary?:boolean)=>Promise<void>, loadCart:(userId:number)=>Promise<any[]>, saveCart:(userId:number,items:any[])=>Promise<void>, loadAllMenuOrders:()=>Promise<Array<{parentId:string|null, orderedIds:string[], hiddenIds:string[]}>>, saveMenuOrder:(parentId:string|null, orderedIds:string[], hiddenIds:string[])=>Promise<void>}} Storage */\r\n\r\n/**\r\n * –°–æ–∑–¥–∞–µ—Ç –¥–≤–∏–∂–æ–∫ –º–µ–Ω—é.\r\n * @param {{saby:object,business?:object,shop?:object,storage:Storage,debug?:number}} params\r\n */\r\nexport async function createEngine({ saby, business, shop, storage, debug = 1 }) {\r\n    const cfg = {\r\n        business: { ...DEFAULTS.business, ...business },\r\n        saby: { ...DEFAULTS.saby, ...saby },\r\n        shop: { ...DEFAULTS.shop, ...shop },\r\n        ui: DEFAULTS.ui\r\n    };\r\n\r\n    // Saby –∫–ª–∏–µ–Ω—Ç\r\n    const SABY = createSabyClient({\r\n        clientId: saby.clientId, secretKey: saby.secretKey, serviceKey: saby.serviceKey,\r\n        authUrl: saby.authUrl, apiBase: saby.apiBase\r\n    });\r\n\r\n    // Runtime –∫—ç—à –∫–∞—Ç–∞–ª–æ–≥–∞/–ø—Ä–∞–π—Å–∞/–ø–æ—Ä—è–¥–∫–∞\r\n    let POINT_ID = null;\r\n    let CATALOG = { byId: new Map(), parentById: new Map(), foldersByParent: new Map(), itemsByParent: new Map(), ROOT: '__root__' };\r\n    const CATEGORY_ORDER = new Map(); // parentId -> { orderedIds:string[], hiddenIds:string[] }\r\n    const STATE = new Map(); // chatId -> { cart, cartLoaded, sortMode?:boolean, currentPriceListId, currentPriceListName, catId?:string|null }\r\n\r\n    const commands = [\r\n        { command: 'menu', description: '–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é' },\r\n        { command: 'cart', description: '–ö–æ—Ä–∑–∏–Ω–∞' },\r\n        { command: 'delivery', description: '–û—Ñ–æ—Ä–º–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É' }\r\n    ];\r\n    if (cfg.business.adminId) commands.push({ command: 'sort', description: '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –º–µ–Ω—é (admin)' });\r\n\r\n    // ========= helpers =========\r\n    const log = (...a) => { if (debug) console.log('[menu6]', ...a); };\r\n\r\n    function getState(chatId) {\r\n        if (!STATE.has(chatId)) STATE.set(chatId, {});\r\n        const st = STATE.get(chatId);\r\n        if (!Array.isArray(st.cart)) st.cart = [];\r\n        if (!st.cartLoaded) st.cartLoaded = false;\r\n        if (!st.currentPriceListId) st.currentPriceListId = cfg.saby.fixedPriceListId;\r\n        if (!st.currentPriceListName) st.currentPriceListName = cfg.saby.fixedPriceListName;\r\n        return st;\r\n    }\r\n\r\n    async function ensureCartLoaded(chatId) {\r\n        const st = getState(chatId);\r\n        if (st.cartLoaded) return st;\r\n        try { st.cart = await storage.loadCart(chatId) || []; } catch {}\r\n        st.cartLoaded = true; return st;\r\n    }\r\n\r\n    function applyOrderFor(parentId, ids) {\r\n        const rec = CATEGORY_ORDER.get(parentId == null ? null : String(parentId));\r\n        if (!rec) return ids.slice();\r\n        const hidden = new Set(rec.hiddenIds || []);\r\n        const order = Array.isArray(rec.orderedIds) ? rec.orderedIds.map(String) : [];\r\n        const visible = ids.filter(x => !hidden.has(String(x)));\r\n        const inOrder = order.filter(x => visible.includes(x));\r\n        const rest = visible.filter(x => !inOrder.includes(x));\r\n        return [...inOrder, ...rest];\r\n    }\r\n\r\n    // ========= –∫–∞—Ç–∞–ª–æ–≥/–ø—Ä–∞–π—Å =========\r\n    async function refreshCatalog() {\r\n        if (!POINT_ID) {\r\n            const pts = await SABY.getPoints();\r\n            POINT_ID = SABY.pickPointId(pts) || null;\r\n            if (!POINT_ID) throw new Error('No Saby pointId');\r\n        }\r\n        const pl = await SABY.getPriceLists(POINT_ID);\r\n        const picked = Array.isArray(pl?.records) ? pl.records.find(r => Number(r.id) === Number(cfg.saby.fixedPriceListId)) : null;\r\n        const pid = picked?.id ?? cfg.saby.fixedPriceListId;\r\n\r\n        const all = await SABY.getNomenclature(POINT_ID, pid, 0, 1000);\r\n\r\n        const byId = new Map(); const parentById = new Map();\r\n        const foldersByParent = new Map(); const itemsByParent = new Map();\r\n        const ROOT = '__root__';\r\n\r\n        const items = Array.isArray(all?.items) ? all.items : Array.isArray(all?.records) ? all.records : [];\r\n        for (const row of items) {\r\n            const id = String(row.id);\r\n            const parentId = row.parentId == null ? ROOT : String(row.parentId);\r\n            const folder = !!row.group || !!row.folder;\r\n            const cost = Number(row.price || row.cost || 0);\r\n\r\n            byId.set(id, { id, name: String(row.name || row.title || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'), folder, cost });\r\n            parentById.set(id, parentId);\r\n\r\n            const map = folder ? foldersByParent : itemsByParent;\r\n            if (!map.has(parentId)) map.set(parentId, []);\r\n            map.get(parentId).push(id);\r\n        }\r\n\r\n        CATALOG = { byId, parentById, foldersByParent, itemsByParent, ROOT };\r\n\r\n        // –ø–æ—Ä—è–¥–æ–∫/—Å–∫—Ä—ã—Ç–∏–µ –∏–∑ –ë–î\r\n        const rows = await storage.loadAllMenuOrders().catch(() => []);\r\n        CATEGORY_ORDER.clear();\r\n        for (const rec of rows) {\r\n            CATEGORY_ORDER.set(rec.parentId == null ? null : String(rec.parentId), {\r\n                orderedIds: (rec.orderedIds || []).map(String),\r\n                hiddenIds:  (rec.hiddenIds  || []).map(String)\r\n            });\r\n        }\r\n        log('catalog refreshed, items:', byId.size);\r\n    }\r\n\r\n    // ========= —Ä–µ–Ω–¥–µ—Ä—ã UI =========\r\n    function mainCategories() {\r\n        const base = (CATALOG.foldersByParent.get(CATALOG.ROOT) || []).slice();\r\n        const ids = applyOrderFor(null, base);\r\n        return ids.map(id => ({ id, name: CATALOG.byId.get(id)?.name || '–ö–∞—Ç–∞–ª–æ–≥' }));\r\n    }\r\n\r\n    function replyKb(categories) {\r\n        const rows = [];\r\n        let row = [];\r\n        for (const c of categories) {\r\n            row.push({ text: c.name });\r\n            if (row.length === 3) { rows.push(row); row = []; }\r\n        }\r\n        if (row.length) rows.push(row);\r\n        rows.push([{ text: 'üìã –ú–µ–Ω—é' }, { text: 'üß∫ –ö–æ—Ä–∑–∏–Ω–∞' }, { text: 'üöö –î–æ—Å—Ç–∞–≤–∫–∞' }]);\r\n        return { reply_markup: { keyboard: rows, resize_keyboard: true, one_time_keyboard: false } };\r\n    }\r\n\r\n    async function __getStartPayload(chatIdOrCtx) {\r\n        const chatId = typeof chatIdOrCtx === 'number' ? chatIdOrCtx : chatIdOrCtx?.chat?.id;\r\n        const st = getState(chatId || 0);\r\n        const cats = mainCategories();\r\n        const text = `–ú–µ–Ω—é: ${st.currentPriceListName}`;\r\n        const extra = replyKb(cats);\r\n        return { text, extra };\r\n    }\r\n\r\n    async function sendStartUi(ctx) {\r\n        const { text, extra } = await __getStartPayload(ctx);\r\n        await ctx.reply(text, extra);\r\n    }\r\n\r\n    async function sendCategory(ctx, catId = null, page = 0) {\r\n        const st = getState(ctx.chat.id);\r\n        st.catId = catId;\r\n\r\n        const parentKey = catId ?? CATALOG.ROOT;\r\n        const folders = applyOrderFor(catId, CATALOG.foldersByParent.get(parentKey) || []);\r\n        const itemsAll = CATALOG.itemsByParent.get(parentKey) || [];\r\n\r\n        // –∞–≤—Ç–æ–ø—Ä–æ–≤–∞–ª–∏–≤–∞–Ω–∏–µ, –µ—Å–ª–∏ –≤ –ø–∞–ø–∫–µ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤\r\n        if (!itemsAll.length && folders.length) {\r\n            return sendCategory(ctx, folders[0], 0);\r\n        }\r\n\r\n        const pageSize = cfg.ui.pageSize;\r\n        const start = page * pageSize;\r\n        const itemsPage = itemsAll.slice(start, start + pageSize);\r\n\r\n        const rows = [];\r\n\r\n        // –ø–æ–¥–ø–∞–ø–∫–∏\r\n        if (folders.length && itemsAll.length) {\r\n            for (const fid of folders) {\r\n                rows.push([{ text: `üìÇ ${CATALOG.byId.get(fid)?.name || '–ö–∞—Ç–∞–ª–æ–≥'}`, callback_data: `${MENU_PREFIX}cat:${encId(fid)}:0` }]);\r\n            }\r\n        }\r\n\r\n        // —Ç–æ–≤–∞—Ä—ã\r\n        for (const iid of itemsPage) {\r\n            const it = CATALOG.byId.get(iid);\r\n            rows.push([{ text: `${it.name} ‚Ä¢ ${priceLabel(it.cost)}`, callback_data: `${MENU_PREFIX}add:${it.id}` }]);\r\n        }\r\n\r\n        // –ø–∞–≥–∏–Ω–∞—Ü–∏—è\r\n        const totalPages = Math.ceil(itemsAll.length / pageSize);\r\n        if (totalPages > 1) {\r\n            const nav = [];\r\n            for (let p = Math.max(0, page - 2); p <= Math.min(totalPages - 1, page + 2); p++) {\r\n                nav.push({ text: p === page ? `üëÅ ${p + 1}` : `${p + 1}`, callback_data: `${MENU_PREFIX}ipage:${encId(catId ?? 'root')}:${p}` });\r\n            }\r\n            rows.push(nav);\r\n        }\r\n\r\n        // –∫–æ—Ä–∑–∏–Ω–∞\r\n        const stCart = await ensureCartLoaded(ctx.chat.id);\r\n        const total = stCart.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n        const count = stCart.cart.reduce((s, r) => s + r.count, 0);\r\n\r\n        rows.push([\r\n            { text: `üß∫ –ö–æ—Ä–∑–∏–Ω–∞ (${count} | ${priceLabel(total)})`, callback_data: `${MENU_PREFIX}cart:show` },\r\n            { text: 'üöö –û—Ñ–æ—Ä–º–∏—Ç—å', callback_data: `${MENU_PREFIX}order:start` }\r\n        ]);\r\n\r\n        const title = catId ? `–ú–µ–Ω—é: ${st.currentPriceListName} / ${CATALOG.byId.get(catId)?.name || ''}` : `–ú–µ–Ω—é: ${st.currentPriceListName}`;\r\n        await ctx.reply(title, { reply_markup: { inline_keyboard: rows } });\r\n    }\r\n\r\n    async function showCart(ctx) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        if (!st.cart.length) return ctx.reply('–ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞.');\r\n        const total = st.cart.reduce((s, r) => s + r.cost * r.count, 0);\r\n        const rows = st.cart.map(r => ([\r\n            { text: '‚àí', callback_data: `${MENU_PREFIX}cart:dec:${r.id}` },\r\n            { text: `${r.name} √ó${r.count}`, callback_data: `${MENU_PREFIX}noop` },\r\n            { text: '+', callback_data: `${MENU_PREFIX}cart:inc:${r.id}` },\r\n            { text: '‚úñ', callback_data: `${MENU_PREFIX}cart:del:${r.id}` }\r\n        ]));\r\n        rows.push([{ text: '–û—á–∏—Å—Ç–∏—Ç—å', callback_data: `${MENU_PREFIX}cart:clear` }, { text: 'üöö –û—Ñ–æ—Ä–º–∏—Ç—å', callback_data: `${MENU_PREFIX}order:start` }]);\r\n        await ctx.reply(\r\n            `üß∫ –ö–æ—Ä–∑–∏–Ω–∞:\\n${st.cart.map(r => `‚Ä¢ ${r.name} √ó ${r.count} = ${priceLabel(r.cost * r.count)}`).join('\\n')}\\n\\n–ò—Ç–æ–≥–æ: ${priceLabel(total)}`,\r\n            { reply_markup: { inline_keyboard: rows } }\r\n        );\r\n    }\r\n\r\n    // ========= –¥–µ–π—Å—Ç–≤–∏—è —Å –∫–æ—Ä–∑–∏–Ω–æ–π =========\r\n    async function addToCart(ctx, itemId) {\r\n        const id = String(itemId);\r\n        const node = CATALOG.byId.get(id);\r\n        if (!node || node.folder) return;\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const row = st.cart.find(r => r.id === id);\r\n        if (row) row.count += 1;\r\n        else st.cart.push({ id, name: node.name, cost: node.cost, count: 1 });\r\n        await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n        await ctx.answerCbQuery(`${node.name} –¥–æ–±–∞–≤–ª–µ–Ω`);\r\n    }\r\n    async function changeQty(ctx, id, delta) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const i = st.cart.findIndex(r => r.id === id);\r\n        if (i < 0) return;\r\n        st.cart[i].count = Math.max(1, (st.cart[i].count || 1) + delta);\r\n        await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n    }\r\n    async function delItem(ctx, id) {\r\n        const st = await ensureCartLoaded(ctx.chat.id);\r\n        const before = st.cart.length;\r\n        st.cart = st.cart.filter(r => r.id !== id);\r\n        if (st.cart.length !== before) await storage.saveCart(ctx.chat.id, st.cart).catch(() => {});\r\n    }\r\n\r\n    // ========= —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∞ =========\r\n    function isAdmin(ctx) { return cfg.business.adminId && Number(ctx.from?.id) === Number(cfg.business.adminId); }\r\n\r\n    async function toggleSortMode(ctx) {\r\n        if (!isAdmin(ctx)) return ctx.reply('–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É.');\r\n        const st = getState(ctx.chat.id);\r\n        st.sortMode = !st.sortMode;\r\n        await ctx.reply(st.sortMode ? '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –í–ö–õ' : '–†–µ–∂–∏–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: –í–´–ö–õ');\r\n    }\r\n\r\n    // ========= delivery flow (–º–∏–Ω–∏–º–∞–ª—å–Ω–æ) =========\r\n    async function startDelivery(ctx) {\r\n        await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π (—É–ª–∏—Ü–∞ –¥–æ–º, –∫–≤–∞—Ä—Ç–∏—Ä–∞):');\r\n        const st = getState(ctx.chat.id);\r\n        st.flow = 'address';\r\n    }\r\n\r\n    async function onText(ctx) {\r\n        const text = (ctx.message?.text || '').trim();\r\n\r\n        // –≥–ª–∞–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏\r\n        if (text === 'üìã –ú–µ–Ω—é') return sendCategory(ctx, null, 0);\r\n        if (text === 'üß∫ –ö–æ—Ä–∑–∏–Ω–∞') return showCart(ctx);\r\n        if (text === 'üöö –î–æ—Å—Ç–∞–≤–∫–∞') return startDelivery(ctx);\r\n\r\n        // –∫–ª–∏–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–æ—Ä–Ω–µ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏\r\n        const cat = mainCategories().find(c => c.name === text);\r\n        if (cat) return sendCategory(ctx, cat.id, 0);\r\n\r\n        // –ø—Ä–æ—Å—Ç–µ–π—à–∏–π —à–∞–≥ –∞–¥—Ä–µ—Å–∞\r\n        const st = getState(ctx.chat.id);\r\n        if (st.flow === 'address') {\r\n            const sugg = await SABY.suggestedAddress(text).catch(()=>null);\r\n            const best = Array.isArray(sugg?.records) ? sugg.records[0] : null;\r\n            if (!best) return ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∞–¥—Ä–µ—Å, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–Ω–∞—á–µ.');\r\n            await storage.saveAddress(ctx.from.id, best.fullAddress || text, best);\r\n            st.flow = 'slot';\r\n            await ctx.reply('–ê–¥—Ä–µ—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏:');\r\n            const minutes = nowTZMinutesSinceMidnight(cfg.business.timeZone);\r\n            const startIdx = Math.max(cfg.business.slotOpenIdx, Math.floor((minutes - 30) / 30));\r\n            const endIdx = cfg.business.slotCloseIdx;\r\n            const row = [];\r\n            for (let idx = startIdx; idx <= Math.min(endIdx, startIdx + 5); idx++) {\r\n                row.push({ text: slotLabel(idx), callback_data: `${MENU_PREFIX}slot:${idx}` });\r\n            }\r\n            return ctx.reply('–î–æ—Å—Ç—É–ø–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞:', { reply_markup: { inline_keyboard: [row] } });\r\n        }\r\n    }\r\n\r\n    async function onAction(ctx) {\r\n        const data = String(ctx.update?.callback_query?.data || '');\r\n        if (!data.startsWith(MENU_PREFIX)) return; // —á—É–∂–∏–µ callback-–∏ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º (–≤–∞—Ä–∏–∞–Ω—Ç 1)\r\n        const cmd = data.slice(MENU_PREFIX.length);\r\n\r\n        // –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∏ –∫–æ—Ä–∑–∏–Ω–∞\r\n        if (cmd.startsWith('cat:')) {\r\n            const [, b64, pageStr] = cmd.split(':'); const id = decId(b64);\r\n            return sendCategory(ctx, id === 'root' ? null : id, Number(pageStr || 0) || 0);\r\n        }\r\n        if (cmd.startsWith('ipage:')) {\r\n            const [, b64, pageStr] = cmd.split(':'); const id = decId(b64);\r\n            return sendCategory(ctx, id === 'root' ? null : id, Number(pageStr || 0) || 0);\r\n        }\r\n        if (cmd.startsWith('add:')) {\r\n            const id = cmd.slice('add:'.length);\r\n            await addToCart(ctx, id);\r\n            return;\r\n        }\r\n        if (cmd === 'cart:show') return showCart(ctx);\r\n        if (cmd.startsWith('cart:dec:')) { await changeQty(ctx, cmd.split(':')[2], -1); return showCart(ctx); }\r\n        if (cmd.startsWith('cart:inc:')) { await changeQty(ctx, cmd.split(':')[2], +1); return showCart(ctx); }\r\n        if (cmd.startsWith('cart:del:')) { await delItem(ctx, cmd.split(':')[2]); return showCart(ctx); }\r\n        if (cmd === 'cart:clear') {\r\n            const st = await ensureCartLoaded(ctx.chat.id);\r\n            st.cart = []; await storage.saveCart(ctx.chat.id, []);\r\n            return showCart(ctx);\r\n        }\r\n\r\n        // —Å–ª–æ—Ç—ã\r\n        if (cmd.startsWith('slot:')) {\r\n            const slotIdx = Number(cmd.split(':')[1]);\r\n            await ctx.answerCbQuery(`–°–ª–æ—Ç ${slotLabel(slotIdx)} –≤—ã–±—Ä–∞–Ω. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –≤—ã–Ω–µ—Å–µ–Ω–æ –≤ TODO.`);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // ========= –ø—É–±–ª–∏—á–Ω—ã–π API =========\r\n    async function attach(bot) {\r\n        await refreshCatalog().catch(e => log('catalog init failed', e?.message || e));\r\n\r\n        // –Ω–∞—à ¬´–≤—Ç–æ—Ä–æ–π /start¬ª ‚Äî –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —á—É–∂–æ–π, —Ç–æ–ª—å–∫–æ –¥–æ–ø–æ–ª–Ω—è–µ—Ç\r\n        bot.start(async (ctx, next) => {\r\n            try {\r\n                if (!ctx.state?.handled) await sendStartUi(ctx);\r\n            } catch {}\r\n            return next && next();\r\n        });\r\n\r\n        bot.command('menu', ctx => sendCategory(ctx, null, 0));\r\n        bot.command('cart', ctx => showCart(ctx));\r\n        bot.command('delivery', ctx => startDelivery(ctx));\r\n        if (cfg.business.adminId) bot.command('sort', ctx => toggleSortMode(ctx));\r\n\r\n        bot.on('text', onText);\r\n\r\n        // —Ç–æ–ª—å–∫–æ –Ω–∞—à–∏ callback-–∏, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å m:\r\n        bot.action(/^m:/, onAction);\r\n    }\r\n\r\n    return {\r\n        attach,\r\n        sendStartUi,\r\n        commands,\r\n        __getStartPayload // –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (getStartPayload)\r\n    };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\index.js": "// –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç: —Ñ–∞–±—Ä–∏–∫–∞ –¥–≤–∏–∂–∫–∞. –ë–∞–∑–∞ ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç 4, —Å –∞–ª–∏–∞—Å–∞–º–∏ –∏–∑ 2/3.\r\n// –ò—Å—Ç–æ—á–Ω–∏–∫ –∏–¥–µ–π API: 4.md (attach/sendStartUi/commands), —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: 2.md (register/startContent) –∏ 3.md (getStartPayload).\r\nimport { createEngine } from './engine.js';\r\n\r\n/**\r\n * @param {Object} config\r\n * @param {Object} config.saby {clientId, secretKey, serviceKey, authUrl?, apiBase?, fixedPriceListId?, fixedPriceListName?}\r\n * @param {Object} config.business { timeZone?, slotOpenIdx?, slotCloseIdx?, adminId? }\r\n * @param {Object} config.shop { shopURL?, successURL?, errorURL? }\r\n * @param {Object} [config.storage]  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∞–¥–∞–ø—Ç–µ—Ä —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (—Å–º. storage/types.js)\r\n * @param {Object} [config.mongo]    –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π mongoose-–∞–¥–∞–ø—Ç–µ—Ä: { url, dbName, connect?: boolean }\r\n * @param {number} [config.debug=1]\r\n * @returns {Promise<{\r\n *   attach: (bot: import('telegraf').Telegraf) => Promise<void>,\r\n *   register: (bot: import('telegraf').Telegraf) => Promise<void>,\r\n *   sendStartUi: (ctx: any) => Promise<void>,\r\n *   getStartPayload: (chatIdOrCtx: number|any) => Promise<{text:string, extra?:object}>,\r\n *   commands: Array<{command:string, description:string}>\r\n * }>}\r\n */\r\nexport default async function createMenuEngine(config = {}) {\r\n    const { saby, business = {}, shop = {}, storage, mongo, debug = 1 } = config;\r\n\r\n    let storageImpl = storage || null;\r\n\r\n    if (!storageImpl && mongo?.url) {\r\n        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–æ–¥–≥—Ä—É–∂–∞–µ–º mongoose-–∞–¥–∞–ø—Ç–µ—Ä (–≤–∞—Ä–∏–∞–Ω—Ç 4), –ù–û –∫–æ–Ω–Ω–µ–∫—Ç ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ connect === true\r\n        const { createMongooseAdapter } = await import('./storage/mongoose.js');\r\n        storageImpl = await createMongooseAdapter({\r\n            mongoUrl: mongo.url,\r\n            dbName: mongo.dbName || 'pizza25',\r\n            connect: Boolean(mongo.connect),\r\n            debug\r\n        });\r\n    }\r\n\r\n    if (!saby?.clientId || !saby?.secretKey || !saby?.serviceKey) {\r\n        throw new Error('[menu6] saby credentials are required (clientId, secretKey, serviceKey)');\r\n    }\r\n    if (!storageImpl) {\r\n        throw new Error('[menu6] storage adapter is required (custom storage or mongo.url with connect flag)');\r\n    }\r\n\r\n    const engine = await createEngine({ saby, business, shop, storage: storageImpl, debug });\r\n\r\n    // –°–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –∞–ª–∏–∞—Å—ã –ø–æ–¥ –≤–∞—Ä–∏–∞–Ω—Ç—ã 2/3:\r\n    engine.register = engine.attach;                   // 2.md register(bot)\r\n    engine.getStartPayload = engine.__getStartPayload; // 3.md getStartPayload(...)\r\n    return engine;\r\n}\r\n\r\nexport { default as createMenuEngine } from './index.js';\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\saby.js": "// –û–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ Saby API. –í–∑—è—Ç–æ –ø–æ —Ñ–æ—Ä–º–µ –∏–∑ 4 –∏ 3: auth, pickPointId, getPriceLists, getNomenclature, suggestedAddress, deliveryCost‚Ä¶\r\n// –ó–¥–µ—Å—å —Ä–æ–≤–Ω–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –¥–≤–∏–∂–∫—É. –ë–µ–∑ –ª–∏—à–Ω–µ–≥–æ.\r\n\r\nimport { /* short */ } from './shared.js';\r\n\r\nexport function createSabyClient({\r\n                                     clientId, secretKey, serviceKey,\r\n                                     authUrl = 'https://online.sbis.ru/oauth/service/',\r\n                                     apiBase = 'https://api.sbis.ru'\r\n                                 }) {\r\n    const RETAIL_BASE = `${apiBase}/retail`;\r\n    const SABY = { token: null, sid: null };\r\n\r\n    async function auth() {\r\n        const res = await fetch(authUrl, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type':'application/json; charset=utf-8', 'Accept':'application/json' },\r\n            body: JSON.stringify({ app_client_id: clientId, app_secret: secretKey, secret_key: serviceKey })\r\n        });\r\n        if (!res.ok) throw new Error(`Saby auth failed: ${res.status}`);\r\n        const data = await res.json();\r\n        SABY.token = data.token; SABY.sid = data.sid;\r\n    }\r\n    function headers() {\r\n        const h = { 'Accept':'application/json' };\r\n        if (SABY.token) h['X-SBISAccessToken'] = SABY.token;\r\n        if (SABY.sid)   h['Cookie'] = `sid=${SABY.sid}`;\r\n        return h;\r\n    }\r\n    async function call(url, opts = {}, retry = true) {\r\n        const res = await fetch(url, { method: opts.method || 'GET', headers: { ...headers(), ...(opts.headers || {}) }, body: opts.body });\r\n        const text = await res.text().catch(() => '');\r\n        if (res.status === 401 && retry) { await auth(); return call(url, opts, false); }\r\n        if (!res.ok) throw new Error(`${url} ‚Üí ${res.status} ${text}`);\r\n        try { return text ? JSON.parse(text) : {}; } catch { return { raw:text }; }\r\n    }\r\n\r\n    const getPoints = () => call(`${RETAIL_BASE}/point/list`);\r\n    function pickPointId(pointsResp) {\r\n        const list = Array.isArray(pointsResp?.salesPoints) ? pointsResp.salesPoints\r\n            : Array.isArray(pointsResp?.records) ? pointsResp.records\r\n                : Array.isArray(pointsResp) ? pointsResp : [];\r\n        return list[0]?.id ?? null;\r\n    }\r\n    const getPriceLists = (pointId, actualDate = new Date()) => {\r\n        const url = new URL(`${RETAIL_BASE}/nomenclature/price-list`);\r\n        url.searchParams.set('pointId', String(pointId));\r\n        url.searchParams.set('actualDate', `${actualDate.toLocaleDateString('ru-RU')} ${actualDate.toLocaleTimeString('ru-RU')}`);\r\n        url.searchParams.set('pageSize', '1000');\r\n        return call(url.toString());\r\n    };\r\n    const getNomenclature = (pointId, priceListId, page = 0, pageSize = 1000) => {\r\n        const url = new URL(`${RETAIL_BASE}/nomenclature/list`);\r\n        url.searchParams.set('pointId', String(pointId));\r\n        url.searchParams.set('priceListId', String(priceListId));\r\n        url.searchParams.set('page', String(page));\r\n        url.searchParams.set('pageSize', String(pageSize));\r\n        return call(url.toString());\r\n    };\r\n\r\n    const suggestedAddress = (addressLine) => {\r\n        const url = new URL(`${RETAIL_BASE}/delivery/suggested-address`);\r\n        url.searchParams.set('address', addressLine);\r\n        return call(url.toString());\r\n    };\r\n\r\n    // –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–∑–æ–≤—ã (deliveryCost, deliveryCalendar, createOrder, paymentLink –∏ —Ç.–¥.) –¥–æ–±–∞–≤–∏–º –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –æ–Ω–ª–∞–π–Ω-–æ–ø–ª–∞—Ç—ã.\r\n    return { getPoints, pickPointId, getPriceLists, getNomenclature, suggestedAddress };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\shared.js": "// –û–±—â–∏–µ —É—Ç–∏–ª–∏—Ç—ã: stable UUID, –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è, —Ü–µ–Ω–∞, b64id, —Ç–µ–ª–µ—Ñ–æ–Ω.\r\nimport crypto from 'crypto';\r\n\r\nexport const priceLabel = v => `${(Number(v) || 0).toFixed(0)} ‚ÇΩ`;\r\nexport const encId = id => Buffer.from(String(id), 'utf8').toString('base64url');\r\nexport const decId = s  => { try { return Buffer.from(String(s), 'base64url').toString('utf8'); } catch { return String(s); } };\r\n\r\nexport function normalizePhone(s) {\r\n    if (!s) return null;\r\n    let p = String(s).replace(/[^\\d+]/g, '');\r\n    if (/^8\\d{10}$/.test(p)) return `+7${p.slice(1)}`;\r\n    if (/^\\+7\\d{10}$/.test(p)) return p;\r\n    if (/^7\\d{10}$/.test(p)) return `+${p}`;\r\n    return null;\r\n}\r\n\r\nexport function generateStableUuid(name, namespace='1b671a64-40d5-491e-99b0-da01ff1f3341') {\r\n    const ns = namespace.replace(/-/g,''); const nsBytes = Buffer.from(ns,'hex');\r\n    const nameBytes = Buffer.from(String(name),'utf8');\r\n    const hash = crypto.createHash('sha1').update(nsBytes).update(nameBytes).digest();\r\n    hash[6] = (hash[6] & 0x0f) | 0x50; hash[8] = (hash[8] & 0x3f) | 0x80;\r\n    const b = hash.subarray(0,16); const hex = b.toString('hex');\r\n    return [hex.slice(0,8),hex.slice(8,12),hex.slice(12,16),hex.slice(16,20),hex.slice(20)].join('-');\r\n}\r\n\r\n// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è Presto (0..47)\r\nexport function normalizeCalendarIntervals(raw) {\r\n    const out = new Set();\r\n    const add = i => { const n = Number(i); if (Number.isInteger(n) && n>=0 && n<=47) out.add(n); };\r\n    const addRange = (a,b) => { let x=+a,y=+b; if (!Number.isFinite(x)||!Number.isFinite(y)) return;\r\n        const s=Math.max(0,Math.min(x,y)), e=Math.min(47,Math.max(x,y)); for (let i=s;i<=e;i++) add(i); };\r\n    const walk = v => {\r\n        if (v==null) return;\r\n        if (typeof v==='number') return add(v);\r\n        if (typeof v==='string') { const s=v.trim(); const m=s.match(/^(\\d{1,2})\\s*-\\s*(\\d{1,2})$/); if (m) return addRange(m[1],m[2]); if (s.toLowerCase()==='all') return addRange(0,47); return add(s); }\r\n        if (Array.isArray(v)) { if (v.length===2 && v.every(x=>Number.isFinite(+x))) return addRange(v[0],v[1]); for (const x of v) walk(x); return; }\r\n        if (typeof v==='object') for (const k of Object.keys(v)) walk(v[k]);\r\n    };\r\n    walk(raw);\r\n    return [...out].sort((a,b)=>a-b);\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\storage\\mongoose.js": "import mongoosePkg from 'mongoose';\r\n\r\nexport async function createMongooseAdapter({ mongoUrl, dbName = 'pizza25', connect = false, debug = 0, mongoose = null }) {\r\n    const m = mongoose || mongoosePkg;\r\n\r\n    if (connect) {\r\n        if (m.connection.readyState === 0) {\r\n            await m.connect(mongoUrl, { dbName, serverSelectionTimeoutMS: 1500 }).catch(() => {});\r\n        }\r\n    }\r\n    const ready = async () => m?.connection?.readyState === 1;\r\n\r\n    const AddressSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        addressFull: { type:String, required:true },\r\n        addressJSON: { type:m.Schema.Types.Mixed, required:true },\r\n        createdAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    AddressSchema.index({ userId:1, addressFull:1 }, { unique:true });\r\n\r\n    const PhoneSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        phone: { type:String, required:true },\r\n        isPrimary: { type:Boolean, default:false },\r\n        createdAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    PhoneSchema.index({ userId:1, phone:1 }, { unique:true });\r\n\r\n    const CartSchema = new m.Schema({\r\n        userId: { type:Number, index:true, required:true },\r\n        items: [{\r\n            id: { type:String, required:true },\r\n            name:{ type:String, required:true },\r\n            cost:{ type:Number, required:true },\r\n            count:{ type:Number, required:true }\r\n        }],\r\n        updatedAt: { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    CartSchema.index({ userId:1 }, { unique:true });\r\n\r\n    const MenuOrderSchema = new m.Schema({\r\n        parentId:   { type:String, index:true, default:null },\r\n        orderedIds: { type:[String], default:[] },\r\n        hiddenIds:  { type:[String], default:[] },\r\n        updatedAt:  { type:Date, default:Date.now }\r\n    }, { versionKey:false });\r\n    MenuOrderSchema.index({ parentId:1 }, { unique:true });\r\n\r\n    const models = m.connection.models;\r\n    const Address   = models.TelegramAddress || m.model('TelegramAddress', AddressSchema);\r\n    const Phone     = models.TelegramPhone   || m.model('TelegramPhone',   PhoneSchema);\r\n    const Cart      = models.TelegramCart    || m.model('TelegramCart',    CartSchema);\r\n    const MenuOrder = models.MenuOrder       || m.model('MenuOrder',       MenuOrderSchema);\r\n\r\n    return {\r\n        ready,\r\n        async getAddresses(userId, limit = 6) {\r\n            if (!await ready()) return [];\r\n            return Address.find({ userId }).sort({ createdAt:-1 }).limit(limit).lean().exec();\r\n        },\r\n        async saveAddress(userId, addressFull, addressJSON) {\r\n            if (!await ready()) return;\r\n            await Address.updateOne({ userId, addressFull }, { $setOnInsert: { addressJSON, createdAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n        },\r\n        async savePhone(userId, phone, isPrimary=false) {\r\n            if (!await ready()) return;\r\n            await Phone.updateOne({ userId, phone }, { $setOnInsert: { isPrimary, createdAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n            if (isPrimary) await Phone.updateMany({ userId, phone: { $ne: phone } }, { $set: { isPrimary:false } }).exec().catch(()=>{});\r\n        },\r\n        async loadCart(userId) {\r\n            if (!await ready()) return [];\r\n            const doc = await Cart.findOne({ userId }).lean().exec();\r\n            return Array.isArray(doc?.items) ? doc.items : [];\r\n        },\r\n        async saveCart(userId, items) {\r\n            if (!await ready()) return;\r\n            await Cart.updateOne({ userId }, { $set: { items: Array.isArray(items) ? items : [], updatedAt:new Date() } }, { upsert:true }).exec().catch(()=>{});\r\n        },\r\n        async loadAllMenuOrders() {\r\n            if (!await ready()) return [];\r\n            return MenuOrder.find({}).lean().exec();\r\n        },\r\n        async saveMenuOrder(parentId, orderedIds=[], hiddenIds=[]) {\r\n            if (!await ready()) return;\r\n            await MenuOrder.updateOne({ parentId: parentId == null ? null : String(parentId) },\r\n                { $set: { orderedIds: orderedIds.map(String), hiddenIds: hiddenIds.map(String), updatedAt:new Date() } },\r\n                { upsert:true }).exec().catch(()=>{});\r\n        }\r\n    };\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\storage\\types.js": "/**\r\n * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –¥–ª—è –¥–≤–∏–∂–∫–∞ (–≤–∞—Ä–∏–∞–Ω—Ç 4). –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Redis/Postgres/—á—Ç–æ —É–≥–æ–¥–Ω–æ.\r\n * –í—Å–µ –º–µ—Ç–æ–¥—ã ‚Äî –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ.\r\n *\r\n * export type Storage = {\r\n *   ready(): Promise<boolean>,\r\n *   getAddresses(userId:number, limit?:number): Promise<any[]>,\r\n *   saveAddress(userId:number, addressFull:string, addressJSON:any): Promise<void>,\r\n *   savePhone(userId:number, phone:string, isPrimary?:boolean): Promise<void>,\r\n *   loadCart(userId:number): Promise<Array<{id:string,name:string,cost:number,count:number}>>,\r\n *   saveCart(userId:number, items:Array<{id:string,name:string,cost:number,count:number}>): Promise<void>,\r\n *   loadAllMenuOrders(): Promise<Array<{parentId:string|null, orderedIds:string[], hiddenIds:string[]}>>,\r\n *   saveMenuOrder(parentId:string|null, orderedIds:string[], hiddenIds:string[]): Promise<void>\r\n * }\r\n */\r\nexport {};\r\n",
    "C:\\Users\\User\\WebstormProjects\\pizzamenu-engine\\src\\util-date.js": "// –í—Ä–µ–º—è –∏ —Å–ª–æ—Ç—ã: —Ç–æ–ª—å–∫–æ Intl API. –ò—Å—Ç–æ—á–Ω–∏–∫ –ø–æ–¥—Ö–æ–¥–∞: –≤–∞—Ä–∏–∞–Ω—Ç—ã 3/4. (–±–µ–∑ luxon)\r\nfunction toTZParts(date, timeZone) {\r\n    const fmt = new Intl.DateTimeFormat('ru-RU', {\r\n        timeZone, year:'numeric', month:'2-digit', day:'2-digit',\r\n        hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false\r\n    });\r\n    const parts = Object.fromEntries(fmt.formatToParts(date).map(p => [p.type, p.value]));\r\n    return {\r\n        y: +parts.year, m:+parts.month, d:+parts.day,\r\n        H:+parts.hour, M:+parts.minute, S:+parts.second\r\n    };\r\n}\r\n\r\nexport function nowTZMinutesSinceMidnight(timeZone) {\r\n    const p = toTZParts(new Date(), timeZone);\r\n    return p.H * 60 + p.M;\r\n}\r\n\r\nexport function slotLabel(halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    if (!Number.isInteger(idx) || idx < 0 || idx > 47) return '‚Äî';\r\n    const start = 30 + idx * 30;\r\n    const h = Math.floor(start / 60), m = start % 60;\r\n    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;\r\n}\r\n\r\nexport function toLocalPrestoDate(dateStr, halfHourIndex) {\r\n    const idx = Number(halfHourIndex);\r\n    const base = 30 + (Number.isInteger(idx) ? idx * 30 : 0);\r\n    const h = Math.floor(base / 60), m = base % 60;\r\n    return `${dateStr} ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`;\r\n}\r\n\r\nexport function isTodayInTZ(isoYYYYMMDD, timeZone) {\r\n    const p = toTZParts(new Date(), timeZone);\r\n    const s = `${String(p.y).padStart(4,'0')}-${String(p.m).padStart(2,'0')}-${String(p.d).padStart(2,'0')}`;\r\n    return s === isoYYYYMMDD;\r\n}\r\n\r\nexport function humanDateShort(isoYYYYMMDD, timeZone) {\r\n    const [Y,M,D] = isoYYYYMMDD.split('-').map(Number);\r\n    const dt = new Date(Date.UTC(Y, M - 1, D));\r\n    return new Intl.DateTimeFormat('ru-RU', { timeZone, day:'2-digit', month:'2-digit', weekday:'short' })\r\n        .format(dt).replace(',', '');\r\n}\r\n"
}