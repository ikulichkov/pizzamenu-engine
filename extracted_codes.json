{
    "C:\\Users\\User\\WebstormProjects\\tg-pizza-lib\\index.js": "console.log('Happy developing ✨')\n",
    "C:\\Users\\User\\WebstormProjects\\tg-pizza-lib\\src\\db.js": "// db.js — адреса/телефоны/корзина + порядок меню (MenuOrder)\r\nimport mongoose from 'mongoose';\r\n\r\nconst DB = { ready: false, Address: null, Phone: null, Cart: null, MenuOrder: null };\r\n\r\n/**\r\n * Инициализация подключения и моделей.\r\n * НИКАКИХ хардкодов URL/имени БД: всё снаружи.\r\n * @param {object} opts\r\n * @param {string} opts.mongoUrl mongodb://127.0.0.1:27017/pizza25\r\n * @param {string} [opts.dbName] например 'pizza25'\r\n * @param {number} [opts.serverSelectionTimeoutMS] по умолчанию 1500\r\n */\r\nexport async function dbInit({ mongoUrl, dbName = 'pizza25', serverSelectionTimeoutMS = 1500 } = {}) {\r\n    if (DB.ready) return true;\r\n    if (!mongoUrl) throw new Error('dbInit: требуется mongoUrl');\r\n\r\n    try {\r\n        await mongoose.connect(mongoUrl, { dbName, serverSelectionTimeoutMS });\r\n\r\n        const AddressSchema = new mongoose.Schema({\r\n            userId:      { type: Number, index: true, required: true },\r\n            addressFull: { type: String, required: true },\r\n            addressJSON: { type: mongoose.Schema.Types.Mixed, required: true },\r\n            createdAt:   { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        AddressSchema.index({ userId: 1, addressFull: 1 }, { unique: true });\r\n\r\n        const PhoneSchema = new mongoose.Schema({\r\n            userId:    { type: Number, index: true, required: true },\r\n            phone:     { type: String, required: true },\r\n            isPrimary: { type: Boolean, default: false },\r\n            createdAt: { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        PhoneSchema.index({ userId: 1, phone: 1 }, { unique: true });\r\n\r\n        // Корзина: один документ на пользователя\r\n        const CartSchema = new mongoose.Schema({\r\n            userId:   { type: Number, index: true, required: true },\r\n            items:    [{\r\n                id:    { type: String, required: true },\r\n                name:  { type: String, required: true },\r\n                cost:  { type: Number, required: true },\r\n                count: { type: Number, required: true }\r\n            }],\r\n            updatedAt: { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        CartSchema.index({ userId: 1 }, { unique: true });\r\n\r\n        // Порядок и скрытие категорий меню (глобально для всех)\r\n        const MenuOrderSchema = new mongoose.Schema({\r\n            parentId:   { type: String, index: true, default: null }, // null == корень\r\n            orderedIds: { type: [String], default: [] },\r\n            hiddenIds:  { type: [String], default: [] },\r\n            updatedAt:  { type: Date, default: Date.now }\r\n        }, { versionKey: false });\r\n        MenuOrderSchema.index({ parentId: 1 }, { unique: true });\r\n\r\n        // Регистрируем модели один раз в рамках подключения\r\n        DB.Address   = mongoose.models.TelegramAddress || mongoose.model('TelegramAddress', AddressSchema);\r\n        DB.Phone     = mongoose.models.TelegramPhone   || mongoose.model('TelegramPhone',   PhoneSchema);\r\n        DB.Cart      = mongoose.models.TelegramCart    || mongoose.model('TelegramCart',    CartSchema);\r\n        DB.MenuOrder = mongoose.models.MenuOrder       || mongoose.model('MenuOrder',       MenuOrderSchema);\r\n\r\n        DB.ready = true;\r\n        return true;\r\n    } catch (e) {\r\n        console.error('[DB] недоступна:', e?.message || e);\r\n        DB.ready = false;\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function dbGetAddresses(userId, limit = 6) {\r\n    if (!await dbInit._ensure()) return [];\r\n    return DB.Address.find({ userId }).sort({ createdAt: -1 }).limit(limit).lean().exec();\r\n}\r\n\r\nexport async function dbSaveAddress(userId, addressFull, addressJSON) {\r\n    if (!await dbInit._ensure()) return;\r\n    try {\r\n        await DB.Address.updateOne(\r\n            { userId, addressFull },\r\n            { $setOnInsert: { addressJSON, createdAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch {}\r\n}\r\n\r\nexport async function dbSavePhone(userId, phone, isPrimary = false) {\r\n    if (!await dbInit._ensure()) return;\r\n    try {\r\n        await DB.Phone.updateOne(\r\n            { userId, phone },\r\n            { $setOnInsert: { isPrimary, createdAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n        if (isPrimary) {\r\n            await DB.Phone.updateMany(\r\n                { userId, phone: { $ne: phone } },\r\n                { $set: { isPrimary: false } }\r\n            ).exec();\r\n        }\r\n    } catch {}\r\n}\r\n\r\n// ====== корзина ======\r\nexport async function dbLoadCart(userId) {\r\n    if (!await dbInit._ensure()) return [];\r\n    const doc = await DB.Cart.findOne({ userId }).lean().exec();\r\n    return Array.isArray(doc?.items) ? doc.items : [];\r\n}\r\nexport async function dbSaveCart(userId, items) {\r\n    if (!await dbInit._ensure()) return;\r\n    try {\r\n        await DB.Cart.updateOne(\r\n            { userId },\r\n            { $set: { items: Array.isArray(items) ? items : [], updatedAt: new Date() } },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch {}\r\n}\r\n\r\n// ====== порядок меню (глобально) ======\r\nexport async function dbLoadAllMenuOrders() {\r\n    if (!await dbInit._ensure()) return [];\r\n    return DB.MenuOrder.find({}).lean().exec();\r\n}\r\n\r\n/**\r\n * Сохраняем порядок и скрытые элементы для родителя\r\n * @param {string|null} parentId\r\n * @param {string[]} orderedIds\r\n * @param {string[]} hiddenIds\r\n */\r\nexport async function dbSaveMenuOrder(parentId, orderedIds = [], hiddenIds = []) {\r\n    if (!await dbInit._ensure()) return;\r\n    try {\r\n        await DB.MenuOrder.updateOne(\r\n            { parentId: parentId == null ? null : String(parentId) },\r\n            {\r\n                $set: {\r\n                    orderedIds: orderedIds.map(String),\r\n                    hiddenIds:  hiddenIds.map(String),\r\n                    updatedAt:  new Date()\r\n                }\r\n            },\r\n            { upsert: true }\r\n        ).exec();\r\n    } catch (e) {\r\n        console.error('[DB] menuOrder save error:', e?.message || e);\r\n    }\r\n}\r\n\r\n/**\r\n * Хитрый хук, чтобы все внешние вызовы сначала сами дергали dbInit({...}).\r\n * Если ты забыл — _ensure просто вернет false.\r\n */\r\ndbInit._ensure = async function _ensure() {\r\n    if (DB.ready) return true;\r\n    console.error('[DB] dbInit не вызывался: сначала вызови dbInit({ mongoUrl, dbName })');\r\n    return false;\r\n};\r\n\r\n// Для тестов/отладки можно вытянуть модели\r\nexport const __models = DB;\r\n",
    "C:\\Users\\User\\WebstormProjects\\tg-pizza-lib\\src\\index.js": "export * from './db.js';\r\nexport * from './uuid.js';\r\nexport * from './presto.js';\r\n",
    "C:\\Users\\User\\WebstormProjects\\tg-pizza-lib\\src\\presto.js": "/**\r\n * Нормализация календаря Presto в список индексов 0..47\r\n * Принимает что угодно: числа/строки/диапазоны/массивы/объекты.\r\n * Возвращает отсортированный массив уникальных индексов.\r\n */\r\nexport function normalizeCalendarIntervals(raw) {\r\n    const out = new Set();\r\n\r\n    const addIndex = (i) => {\r\n        const n = Number(i);\r\n        if (Number.isInteger(n) && n >= 0 && n <= 47) out.add(n);\r\n    };\r\n\r\n    const addRange = (a, b) => {\r\n        let x = Number(a), y = Number(b);\r\n        if (!Number.isFinite(x) || !Number.isFinite(y)) return;\r\n        const start = Math.max(0, Math.min(x, y));\r\n        const end   = Math.min(47, Math.max(x, y));\r\n        for (let i = start; i <= end; i++) addIndex(i);\r\n    };\r\n\r\n    const walk = (val) => {\r\n        if (val == null) return;\r\n\r\n        if (typeof val === 'number') { addIndex(val); return; }\r\n\r\n        if (typeof val === 'string') {\r\n            const s = val.trim();\r\n            if (s.toLowerCase() === 'all') { addRange(0, 47); return; }\r\n            const m = s.match(/^(\\d{1,2})\\s*-\\s*(\\d{1,2})$/);\r\n            if (m) { addRange(m[1], m[2]); return; }\r\n            addIndex(s);\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(val)) {\r\n            if (val.length === 2 && val.every(x => Number.isFinite(Number(x)))) {\r\n                addRange(val[0], val[1]);\r\n            } else {\r\n                for (const v of val) walk(v);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (typeof val === 'object') {\r\n            for (const k of Object.keys(val)) walk(val[k]);\r\n        }\r\n    };\r\n\r\n    walk(raw);\r\n    return [...out].sort((a, b) => a - b);\r\n}\r\n",
    "C:\\Users\\User\\WebstormProjects\\tg-pizza-lib\\src\\uuid.js": "import crypto from 'crypto';\r\n\r\n/**\r\n * UUID v5 по имени и namespace (как в оригинале), без сторонних пакетов.\r\n * @param {string|number} name\r\n * @param {string} [namespace='1b671a64-40d5-491e-99b0-da01ff1f3341']\r\n */\r\nexport function generateStableUuid(name, namespace = '1b671a64-40d5-491e-99b0-da01ff1f3341') {\r\n    const ns = namespace.replace(/-/g, '');\r\n    const nsBytes = Buffer.from(ns, 'hex');\r\n    const nameBytes = Buffer.from(String(name), 'utf8');\r\n    const hash = crypto.createHash('sha1').update(nsBytes).update(nameBytes).digest();\r\n    hash[6] = (hash[6] & 0x0f) | 0x50;\r\n    hash[8] = (hash[8] & 0x3f) | 0x80;\r\n    const b = hash.subarray(0, 16);\r\n    const hex = b.toString('hex');\r\n    return [hex.slice(0,8),hex.slice(8,12),hex.slice(12,16),hex.slice(16,20),hex.slice(20)].join('-');\r\n}\r\n"
}